<!DOCTYPE html>
<html lang="en">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="description" content="其实不过是杂记">



<title>Python 优化 | 小记</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    



    
    
        
    


</head>
<body class="dark-theme">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">小记</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input hidden id="switch_default" type="checkbox" class="switch_default">
                <label style="display:none" for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">小记</a><a id="mobile-toggle-theme">·&nbsp;Dark</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Python 优化</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Arthur Lu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">April 29, 2020&nbsp;&nbsp;23:22:55</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="一、性能调优"><a href="#一、性能调优" class="headerlink" title="一、性能调优"></a>一、性能调优</h2><p>Python 内置的性能分析器有两种：</p>
<ul>
<li>cProfile，这是一个 C 扩展模块，推荐使用。</li>
<li>profile，这是纯 Python 模块，相比于 cProfile 会显著增加性能分析的耗时。</li>
</ul>
<p>无论是 cProfile 或是 profile 都只能分析单进程单线程的代码，不适用于并行进程的分析。</p>
<p>对于多线程场景：</p>
<ul>
<li>可以使用 <a href="https://pypi.org/project/yappi/" target="_blank" rel="noopener">yappi 模块</a></li>
<li>仍然使用 cProfile 模块，对每个线程启动 cProfile 进行分析。</li>
</ul>
<h3 id="1-1-cProfile"><a href="#1-1-cProfile" class="headerlink" title="1.1 cProfile"></a>1.1 cProfile</h3><p>假设我们现在有一个简单的 Python 求和功能脚本：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(eles)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(eles)):</span><br><span class="line">        sum += eles[i]</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    eles = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        eles.append(random.random())</span><br><span class="line">    mysum(eles)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>运行该脚本，将会进行如下的输出：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line">        20007 <span class="keyword">function</span> calls <span class="keyword">in</span> 0.005 seconds</span><br><span class="line"></span><br><span class="line">   Ordered by: standard name</span><br><span class="line"></span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(<span class="keyword">function</span>)</span><br><span class="line">        1    0.000    0.000    0.005    0.005 &lt;string&gt;:1(&lt;module&gt;)</span><br><span class="line">        1    0.003    0.003    0.005    0.005 test.py:11(main)</span><br><span class="line">        1    0.001    0.001    0.001    0.001 test.py:4(mysum)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;len&#125;</span><br><span class="line">    10000    0.001    0.000    0.001    0.000 &#123;method <span class="string">'append'</span> of <span class="string">'list'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'disable'</span> of <span class="string">'_lsprof.Profiler'</span> objects&#125;</span><br><span class="line">    10000    0.001    0.000    0.001    0.000 &#123;method <span class="string">'random'</span> of <span class="string">'_random.Random'</span> objects&#125;</span><br><span class="line">        2    0.000    0.000    0.000    0.000 &#123;range&#125;</span><br></pre></td></tr></table></figure></p>
<p>cProfile 会将性能分析输出为一个报表，报表的字段含义：</p>
<ul>
<li>ncalls, 函数的执行次数。如果函数是递归调用，则 ncalls 为 : <code>{总调用次数}/{主动调用次数}</code>。</li>
<li>tottime, 函数的总运行时间（不包含调用函数所消耗的时间）。</li>
<li>percall, 函数运行一次的平均时间，即 percall == tottime / ncalls。如果函数是递归调用，则运行时间为 percall == cumtime / 总调用次数。</li>
<li>cumtime, 函数及其子函数的累计耗时。递归调用时，会包含递归的时间</li>
<li>percall, 函数运行一次的累计时间，即  percall == cumtime / ncalls。如果函数是递归调用，则运行时间为 percall == cumtime / 主动调用次数。</li>
</ul>
<p>递归调用的测试情况：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_recursion.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum_recursion</span><span class="params">(eles)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">return</span> eles[<span class="number">0</span>] + mysum_recursion(eles[<span class="number">1</span>:]) <span class="keyword">if</span> eles <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    eles = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">        eles.append(random.random())</span><br><span class="line">    <span class="comment"># 主动调用两次，每次主动调用都触发 10 次的 mysum_recursion 被调用</span></span><br><span class="line">    mysum_recursion(eles)</span><br><span class="line">    mysum_recursion(eles)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cProfile.run(<span class="string">'main()'</span>)</span><br></pre></td></tr></table></figure></p>
<p>性能分析调用<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ python test_recursion.py</span><br><span class="line">         62 <span class="keyword">function</span> calls (44 primitive calls) <span class="keyword">in</span> 0.201 seconds</span><br><span class="line"></span><br><span class="line">   Ordered by: standard name</span><br><span class="line"></span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(<span class="keyword">function</span>)</span><br><span class="line">        1    0.000    0.000    0.201    0.201 &lt;string&gt;:1(&lt;module&gt;)</span><br><span class="line">        1    0.000    0.000    0.201    0.201 test_recursion.py:10(main)</span><br><span class="line">     20/2    0.000    0.000    0.201    0.101 test_recursion.py:5(mysum_recursion)</span><br><span class="line">        9    0.000    0.000    0.000    0.000 &#123;method <span class="string">'append'</span> of <span class="string">'list'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'disable'</span> of <span class="string">'_lsprof.Profiler'</span> objects&#125;</span><br><span class="line">        9    0.000    0.000    0.000    0.000 &#123;method <span class="string">'random'</span> of <span class="string">'_random.Random'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;range&#125;</span><br><span class="line">       20    0.201    0.010    0.201    0.010 &#123;time.sleep&#125;</span><br></pre></td></tr></table></figure></p>
<p>cProfile 有 3 种常用的调用方式：</p>
<ul>
<li><p>对某个函数进行性能分析</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line">cProfile.run(command, filename=<span class="keyword">None</span>, sort=<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>command, 函数执行的命令，cProfile 模块会通过 exec 开启新的进程来执行相应的函数并进行性能分析。</li>
<li>filename, 性能分析结果输出到某个文件，如果为 None，则输出到 stdout。</li>
<li>sort, 性能分析的排序方式。</li>
</ul>
</li>
<li><p>对现有脚本进行分析<br>  cProfile 提供了命令行工具，可以对现有的 Python 脚本代码进行性能分析：</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m cProfile [-o output_file] [-s sort_order] (-m module | myscript.py)</span><br></pre></td></tr></table></figure>
<ul>
<li>-o 指定将性能分析结果输出到某个文件，输出的是二进制格式。</li>
<li>-s 指定排序方式<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m cProfile -o prof.txt -s ncalls test.py</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对某个代码块进行分析</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"></span><br><span class="line">prof = cProfile.profile()</span><br><span class="line">prof.enable()</span><br><span class="line"><span class="comment"># do something</span></span><br><span class="line">prof.disable()</span><br><span class="line">prof.print_stats()</span><br><span class="line"><span class="comment"># 输出成文件按</span></span><br><span class="line"><span class="comment"># prof.dump_stats("prof.stat")</span></span><br></pre></td></tr></table></figure>
<p>  如果是对某个函数进行测试，可以用runcall方法进行简化:</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"></span><br><span class="line">prof = cProfile.profile()</span><br><span class="line">prof.runcall(test)</span><br><span class="line">prof.print_stats()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在进行报表输出时，通常是需要指定排序方式的，排序方式的参数取值有两种：</p>
<ul>
<li>字符串</li>
<li>SortKey 枚举（pstats模块）</li>
</ul>
<p>字符串取值对应的排序方式:</p>
<table>
<thead>
<tr>
<th>字符串</th>
<th>参数对应的意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ncalls</td>
<td>被调用的次数</td>
</tr>
<tr>
<td>cumulative</td>
<td>函数运行的总时间</td>
</tr>
<tr>
<td>file</td>
<td>文件名</td>
</tr>
<tr>
<td>module</td>
<td>模块名</td>
</tr>
<tr>
<td>pcalls</td>
<td>简单调用统计</td>
</tr>
<tr>
<td>line</td>
<td>行号</td>
</tr>
<tr>
<td>name</td>
<td>函数名</td>
</tr>
<tr>
<td>nfl</td>
<td>name &amp; file &amp; line</td>
</tr>
<tr>
<td>stdname</td>
<td>标准函数名</td>
</tr>
<tr>
<td>time</td>
<td>函数运行时间(不包括子函数时间)，即tottime</td>
</tr>
</tbody>
</table>
<p>这里仅列出常见的 cProfile 使用方式，cProfile 更多的接口调用可以参考 <a href="https://docs.python.org/zh-cn/3.7/library/profile.html#module-cProfile" target="_blank" rel="noopener">module-cProfile</a></p>
<h3 id="1-2-pstats"><a href="#1-2-pstats" class="headerlink" title="1.2 pstats"></a>1.2 pstats</h3><p>cProfile 中的排序功能实际上是借助的 pstats 模块，实际上 pstats 除了排序功能外，还有其他强大的功能。</p>
<p>pstats 在使用前，需要使用 profile 的数据进行初始化，可以使用 profile 对象，也可以使用 profile 的文件进行初始化：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_by_profile_object</span><span class="params">()</span>:</span></span><br><span class="line">    pr = cProfile.Profile()</span><br><span class="line">    pr.enable()</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    pr.disable()</span><br><span class="line">    p = pstats.Stats(pr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_by_profile_file</span><span class="params">()</span>:</span></span><br><span class="line">    pr = cProfile.Profile()</span><br><span class="line">    pr.enable()</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    pr.disable()</span><br><span class="line">    pr.dumo_stats(<span class="string">"pr.txt"</span>)</span><br><span class="line">    p = pstats.Stats(<span class="string">"pr.txt"</span>)</span><br></pre></td></tr></table></figure></p>
<p>pstats 提供以下的功能：</p>
<ul>
<li><p>对 profile 的分析进行排序</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = pstats.Stats(pr)</span><br><span class="line">p.sort_stats(<span class="string">"time"</span>).print_stats()</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出函数的调用者以及对应的调用次数</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_stats_caller.py</span></span><br><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mysum</span><span class="params">(eles)</span>:</span></span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(eles)):</span><br><span class="line">        sum += eles[i]</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    eles = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">        eles.append(random.random())</span><br><span class="line">    mysum(eles)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    pr = cProfile.Profile()</span><br><span class="line">    pr.enable()</span><br><span class="line">    main()</span><br><span class="line">    pr.disable()</span><br><span class="line">    p = pstats.Stats(pr)</span><br><span class="line">    p.print_callers()</span><br></pre></td></tr></table></figure>
<p>  运行后输出:</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python test_stats_caller.py</span><br><span class="line">Random listing order was used</span><br><span class="line"></span><br><span class="line">Function                                          was called by...</span><br><span class="line">                                                    ncalls  tottime  cumtime</span><br><span class="line">&#123;method <span class="string">'append'</span> of <span class="string">'list'</span> objects&#125;               &lt;-   10000    0.001    0.001  test_stats_caller.py:11(main)</span><br><span class="line">test_stats_caller.py:5(mysum)                     &lt;-       1    0.001    0.001  test_stats_caller.py:11(main)</span><br><span class="line">&#123;method <span class="string">'random'</span> of <span class="string">'_random.Random'</span> objects&#125;     &lt;-   10000    0.001    0.001  test_stats_caller.py:11(main)</span><br><span class="line">&#123;len&#125;                                             &lt;-       1    0.000    0.000  test_stats_caller.py:5(mysum)</span><br><span class="line">test_stats_caller.py:11(main)                     &lt;-</span><br><span class="line">&#123;method <span class="string">'disable'</span> of <span class="string">'_lsprof.Profiler'</span> objects&#125;  &lt;-</span><br><span class="line">&#123;range&#125;                                           &lt;-       1    0.000    0.000  test_stats_caller.py:5(mysum)</span><br><span class="line">                                                           1    0.000    0.000  test_stats_caller.py:11(main)</span><br></pre></td></tr></table></figure>
<p>  左边是函数，右边是该函数的调用者以及调用次数、时间等信息。</p>
</li>
</ul>
<h3 id="1-3-timeit"><a href="#1-3-timeit" class="headerlink" title="1.3 timeit"></a>1.3 timeit</h3><p>如果希望计算一段代码的耗时，我们通常会这样做:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line"></span><br><span class="line">now = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    test()</span><br><span class="line">cost = time.time() - now</span><br></pre></td></tr></table></figure></p>
<p>除此之外，我们可以用 timeit 进行方便的耗时计算：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 10 次 test() 的耗时</span></span><br><span class="line">timeit.timeit(stmt=<span class="string">"test()"</span>, setup=<span class="string">"from __main__ import test"</span>, number=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># timeit 运行 2 次，每次 timeit 计算 10 次 test() 的耗时，返回列表</span></span><br><span class="line">timeit.repeat(stmt=<span class="string">"test()"</span>, setup=<span class="string">"from __main__ import test"</span>, number=<span class="number">10</span>, repeat=<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>需要注意，repeat 是串行连续的运行 timeit 计算耗时，而不是同时并行计算 timeit 的耗时。</p>
<h3 id="1-4-火焰图"><a href="#1-4-火焰图" class="headerlink" title="1.4 火焰图"></a>1.4 火焰图</h3><p>由 cProfile 生成的文件，可以进一步生成火焰图：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装模块</span></span><br><span class="line">$ pip install flameprof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成火焰图（requests.prof 是 cProfile 生成的 profile 文件）</span></span><br><span class="line">$ flameprof requests.prof &gt; requests.svg</span><br></pre></td></tr></table></figure>
<h3 id="1-5-案例分析"><a href="#1-5-案例分析" class="headerlink" title="1.5 案例分析"></a>1.5 案例分析</h3><p>这里对 DBUtils 库提供的连接池的多线程并发性能做一个测试和调优。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dbutils_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_db_pool = PooledDB(MySQLdb,</span><br><span class="line">                     mincached=<span class="number">30</span>,</span><br><span class="line">                     host=<span class="string">"aaa.bbb.ccc.ddd"</span>,</span><br><span class="line">                     user=<span class="string">"xxxx"</span>,</span><br><span class="line">                     passwd=<span class="string">"yyyy"</span>,</span><br><span class="line">                     port=<span class="number">3306</span>,</span><br><span class="line">                     db=<span class="string">"dbname"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query_</span><span class="params">(idx)</span>:</span></span><br><span class="line">    connection = g_db_pool.connection()</span><br><span class="line">    cursor = connection.cursor(MySQLdb.cursors.DictCursor)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        sql = <span class="string">"SELECT uuid FROM table WHERE uuid = 1"</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        item = cursor.fetchone()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        connection.rollback()</span><br><span class="line">        <span class="keyword">raise</span> e</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        connection.commit()</span><br><span class="line">        cursor.close()</span><br><span class="line">        connection.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(idx, lock)</span>:</span></span><br><span class="line">    prof = cProfile.Profile()</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"=================== %s start ==============="</span> % idx</span><br><span class="line">    prof.runcall(query_, idx)</span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"=================== %s finsh ==============="</span> % idx</span><br><span class="line">    prof.dump_stats(<span class="string">"%s.out"</span> % idx)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        threads.append(threading.Thread(target=query, args=(i, lock)))</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">import</span> timeit</span><br><span class="line">    cost = timeit.timeit(stmt=<span class="string">"main()"</span>, setup=<span class="string">"from __main__ import main"</span>, number=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"cost:"</span>, cost</span><br></pre></td></tr></table></figure></p>
<p>上述的代码会初始化一个有 30 个连接的连接池，并开启 1k 个线程，同时从连接池中获取连接并执行 sql 语句。</p>
<ul>
<li>通过 timeit 对整个 1k 次查询进行耗时统计。</li>
<li>通过 cProfile 对每个线程的执行的情况进行统计，并将每个线程的执行情况序列化到文件中。</li>
</ul>
<p>还需要一个程序可以将 profile 文件进行解析：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print_profile.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line"></span><br><span class="line">id_ = sys.argv[<span class="number">1</span>] <span class="keyword">if</span> len(sys.argv) &gt;= <span class="number">2</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">p = pstats.Stats(<span class="string">"%s.out"</span> % id_)</span><br><span class="line">p.sort_stats(<span class="string">"time"</span>).print_stats()</span><br><span class="line"><span class="comment"># p.sort_stats("time").print_callers()</span></span><br></pre></td></tr></table></figure></p>
<p>现在来看下运行的情况：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">$ python dbutils_test.py</span><br><span class="line">cost: 6.25373601913</span><br><span class="line"></span><br><span class="line">$ print_profile.py 999</span><br><span class="line">Tue May  5 00:42:21 2020    999.out</span><br><span class="line"></span><br><span class="line">         198 <span class="keyword">function</span> calls <span class="keyword">in</span> 6.007 seconds</span><br><span class="line"></span><br><span class="line">   Ordered by: internal time</span><br><span class="line"></span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(<span class="keyword">function</span>)</span><br><span class="line">        2    5.996    2.998    5.996    2.998 &#123;method <span class="string">'acquire'</span> of <span class="string">'thread.lock'</span> objects&#125;</span><br><span class="line">        1    0.004    0.004    0.005    0.005 /usr/lib64/python2.7/site-packages/MySQLdb/connections.py:62(__init__)</span><br><span class="line">        1    0.002    0.002    0.002    0.002 &#123;method <span class="string">'query'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.001    0.001    0.001    0.001 /usr/lib64/python2.7/site-packages/MySQLdb/connections.py:240(autocommit)</span><br><span class="line">        1    0.001    0.001    0.001    0.001 &#123;method <span class="string">'commit'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.001    0.001    0.001    0.001 &#123;method <span class="string">'rollback'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    6.007    6.007 dbutils_test.py:20(query_)</span><br><span class="line">        1    0.000    0.000    4.634    4.634 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:277(connection)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'store_result'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.006    0.006 /usr/lib64/python2.7/site-packages/MySQLdb/__init__.py:78(Connect)</span><br><span class="line">       58    0.000    0.000    0.000    0.000 &#123;isinstance&#125;</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:435(__getattr__)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:142(_do_get_result)</span><br><span class="line">        2    0.000    0.000    5.996    2.998 /usr/lib64/python2.7/threading.py:146(acquire)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:75(__init__)</span><br><span class="line">        1    0.000    0.000    1.369    1.369 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:356(cache)</span><br><span class="line">        4    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/connections.py:40(numeric_part)</span><br><span class="line">        1    0.000    0.000    0.006    0.006 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:147(__init__)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:528(__init__)</span><br><span class="line">        4    0.000    0.000    0.000    0.000 &#123;method <span class="string">'match'</span> of <span class="string">'_sre.SRE_Pattern'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.006    0.006 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:209(_create)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:107(_warning_check)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/threading.py:186(release)</span><br><span class="line">        2    0.000    0.000    1.369    0.684 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:427(close)</span><br><span class="line">        1    0.000    0.000    0.002    0.002 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:315(_do_query)</span><br><span class="line">        1    0.000    0.000    0.001    0.001 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:442(rollback)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:122(nextset)</span><br><span class="line">        1    0.000    0.000    0.002    0.002 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:591(tough_method)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:692(__getattr__)</span><br><span class="line">        1    0.000    0.000    0.002    0.002 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:353(_query)</span><br><span class="line">        1    0.000    0.000    0.006    0.006 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:111(connect)</span><br><span class="line">        3    0.000    0.000    0.000    0.000 &#123;method <span class="string">'items'</span> of <span class="string">'dict'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:362(fetchone)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 &#123;method <span class="string">'release'</span> of <span class="string">'thread.lock'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:351(_get_result)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;built-in method fetch_row&#125;</span><br><span class="line">        1    0.000    0.000    0.002    0.002 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:164(execute)</span><br><span class="line">        5    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:159(_get_db)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 &#123;method <span class="string">'split'</span> of <span class="string">'str'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.001    0.001 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:427(commit)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/threading.py:375(notify)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:324(_fetch_row)</span><br><span class="line">        1    0.000    0.000    0.006    0.006 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:271(steady_connection)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:513(cursor)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/connections.py:245(cursor)</span><br><span class="line">        5    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/threading.py:63(_note)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:576(close)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:97(close)</span><br><span class="line">        3    0.000    0.000    0.000    0.000 &#123;method <span class="string">'startswith'</span> of <span class="string">'str'</span> objects&#125;</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:559(_clearsizes)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:475(_cursor)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/connections.py:301(set_character_set)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:342(_ping_check)</span><br><span class="line">        1    0.000    0.000    0.001    0.001 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:330(_reset)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 &#123;_weakref.proxy&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:380(fetchall)</span><br><span class="line">        5    0.000    0.000    0.000    0.000 &#123;thread.get_ident&#125;</span><br><span class="line">        4    0.000    0.000    0.000    0.000 &#123;method <span class="string">'group'</span> of <span class="string">'_sre.SRE_Match'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;_mysql.get_client_info&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:92(__del__)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:383(threadsafety)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:589(_get_tough_method)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'pop'</span> of <span class="string">'list'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:412(__init__)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:103(_check_executed)</span><br><span class="line">        4    0.000    0.000    0.000    0.000 &#123;getattr&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/connections.py:206(_get_unicode_literal)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:358(_post_get_result)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;built-in method describe&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:308(_store)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 &#123;len&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'affected_rows'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;built-in method field_flags&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/threading.py:237(_is_owned)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'next_result'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'copy'</span> of <span class="string">'dict'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'get_server_info'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'disable'</span> of <span class="string">'_lsprof.Profiler'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'info'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'insert_id'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:298(_setsession)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:442(__del__)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'get_autocommit'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'get'</span> of <span class="string">'dict'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;callable&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'warning_count'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'append'</span> of <span class="string">'list'</span> objects&#125;</span><br><span class="line">        2    0.000    0.000    0.000    0.000 &#123;method <span class="string">'character_set_name'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/connections.py:201(_get_string_literal)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:564(_setsizes)</span><br><span class="line">        5    0.000    0.000    0.000    0.000 &#123;method <span class="string">'pop'</span> of <span class="string">'dict'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:703(__del__)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/connections.py:211(_get_string_decoder)</span><br></pre></td></tr></table></figure></p>
<p>从上述可以看出：</p>
<ul>
<li>1k 个线程同时从连接池中获取连接，然后进行查询总耗时 6s。</li>
<li>对于单个线程的耗时主要在线程锁的获取上，上锁的总次数是两次，总耗时接近 6s。</li>
</ul>
<p>通过 <code>p.print_callers()</code> 的方式打印调用情况，可以看出锁的耗时主要是在 <code>db_pool.connection()</code> 上，即主要耗时主要是在获取连接时。</p>
<p>分析代码后可以发现，可以知道获取获取连接之所以耗时的原因：</p>
<ul>
<li>在获取连接前 DBUtils 会先进行上锁，并且做以下处理：<ul>
<li>DBUtils 的默认处理方式是：如果在获取连接时，连接池中的连接不足，会新建新的连接。在测试场景中，连接池中的连接个数有 30 个，但是同时有 1k 个线程同时获取连接，因此在获取连接时会大量进行连接建立。</li>
<li>每次获取连接的时候，都会通过 ping_check() 校验。</li>
</ul>
</li>
<li>每个线程在归连接给连接池的时候，默认会上锁，然后进行连接重置。这个重置其实就是若连接没有关闭，会被回滚（通常连接被连接池回收，并不意味着连接池关闭）。释放和获取连接时，申请的均是同一个锁，因此这会延长获取连接时候的阻塞时间。</li>
</ul>
<p>直接通过 PoolDB 的初始化参数进行优化：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">g_db_pool = PooledDB(MySQLdb,</span><br><span class="line">                     mincached=<span class="number">30</span>,</span><br><span class="line">                     maxcached=<span class="number">30</span>,</span><br><span class="line">                     blocking=<span class="keyword">True</span>,</span><br><span class="line">                     host=<span class="string">"aaa.bbb.ccc.ddd"</span>,</span><br><span class="line">                     user=<span class="string">"xxxx"</span>,</span><br><span class="line">                     passwd=<span class="string">"yyyy"</span>,</span><br><span class="line">                     port=<span class="number">3306</span>,</span><br><span class="line">                     db=<span class="string">"dbname"</span>,</span><br><span class="line">                     ping=<span class="number">0</span>,</span><br><span class="line">                     reset=<span class="keyword">False</span>,)</span><br></pre></td></tr></table></figure></p>
<p>连接池初始化连接有 30 个，且最大只有 30 个，当线程获取连接时如果连接池已空，则阻塞等待连接归还。获取连接时禁止 ping_check，释放连接时禁止重置连接。</p>
<p>重新运行测试:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">$ python dbutils_test.py</span><br><span class="line">cost: 1.19736599922</span><br><span class="line"></span><br><span class="line">$ python print_profile.py 999</span><br><span class="line">Tue May  5 01:05:42 2020    999.out</span><br><span class="line"></span><br><span class="line">         98 <span class="keyword">function</span> calls <span class="keyword">in</span> 0.005 seconds</span><br><span class="line"></span><br><span class="line">   Ordered by: internal time</span><br><span class="line"></span><br><span class="line">   ncalls  tottime  percall  cumtime  percall filename:lineno(<span class="keyword">function</span>)</span><br><span class="line">        1    0.002    0.002    0.002    0.002 &#123;method <span class="string">'query'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.002    0.002    0.002    0.002 &#123;method <span class="string">'commit'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.001    0.001    0.001    0.001 &#123;method <span class="string">'next_result'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'store_result'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        2    0.000    0.000    0.000    0.000 &#123;method <span class="string">'acquire'</span> of <span class="string">'thread.lock'</span> objects&#125;</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/threading.py:146(acquire)</span><br><span class="line">        1    0.000    0.000    0.005    0.005 dbutils_test.py:20(query_)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:92(__del__)</span><br><span class="line">        1    0.000    0.000    0.002    0.002 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:427(commit)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:142(_do_get_result)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:277(connection)</span><br><span class="line">        1    0.000    0.000    0.001    0.001 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:122(nextset)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:356(cache)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:75(__init__)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:692(__getattr__)</span><br><span class="line">        1    0.000    0.000    0.002    0.002 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:591(tough_method)</span><br><span class="line">        1    0.000    0.000    0.002    0.002 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:315(_do_query)</span><br><span class="line">        5    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:159(_get_db)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:427(close)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;built-in method fetch_row&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:475(_cursor)</span><br><span class="line">        2    0.000    0.000    0.001    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:97(close)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:107(_warning_check)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/threading.py:186(release)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:351(_get_result)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:435(__getattr__)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:528(__init__)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/connections.py:245(cursor)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:358(_post_get_result)</span><br><span class="line">        2    0.000    0.000    0.001    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:576(close)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/threading.py:375(notify)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:362(fetchone)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:564(_setsizes)</span><br><span class="line">        1    0.000    0.000    0.002    0.002 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:164(execute)</span><br><span class="line">        4    0.000    0.000    0.000    0.000 &#123;getattr&#125;</span><br><span class="line">        2    0.000    0.000    0.000    0.000 &#123;method <span class="string">'release'</span> of <span class="string">'thread.lock'</span> objects&#125;</span><br><span class="line">        5    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/threading.py:63(_note)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:380(fetchall)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'insert_id'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:559(_clearsizes)</span><br><span class="line">        1    0.000    0.000    0.002    0.002 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:353(_query)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:412(__init__)</span><br><span class="line">        2    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:103(_check_executed)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;built-in method describe&#125;</span><br><span class="line">        3    0.000    0.000    0.000    0.000 &#123;len&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/site-packages/MySQLdb/cursors.py:324(_fetch_row)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/PooledDB.py:442(__del__)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'affected_rows'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'warning_count'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:589(_get_tough_method)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;isinstance&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib64/python2.7/threading.py:237(_is_owned)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:383(threadsafety)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:703(__del__)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'pop'</span> of <span class="string">'list'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:513(cursor)</span><br><span class="line">        3    0.000    0.000    0.000    0.000 &#123;method <span class="string">'startswith'</span> of <span class="string">'str'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:330(_reset)</span><br><span class="line">        3    0.000    0.000    0.000    0.000 /usr/lib/python2.7/site-packages/DBUtils/SteadyDB.py:342(_ping_check)</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;_weakref.proxy&#125;</span><br><span class="line">        5    0.000    0.000    0.000    0.000 &#123;thread.get_ident&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'info'</span> of <span class="string">'_mysql.connection'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;built-in method field_flags&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'items'</span> of <span class="string">'dict'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'append'</span> of <span class="string">'list'</span> objects&#125;</span><br><span class="line">        1    0.000    0.000    0.000    0.000 &#123;method <span class="string">'disable'</span> of <span class="string">'_lsprof.Profiler'</span> objects&#125;</span><br></pre></td></tr></table></figure></p>
<p>换了一种初始化方式后，查询效率大幅度提升，总耗时 1.19 s，并且每个连接池的锁耗时不再成为瓶颈。</p>
<p>需要注意，上述只是使用 cProfile 进行性能调优的一个示例，不代表在实际中使用 DBUtils 时需要这样用，因为如果关闭了 ping_check 和 reset，意味着放弃连接的可靠性。</p>
<p>实际场景中，如果使用 DBUtils 又对性能有要求，可以考虑以下处理方式：</p>
<ul>
<li>关闭 ping_check 和 reset，通过业务侧代码在取出连接后进行 ping_check 和 reset 来检测连接以及归还前的重置。</li>
<li>将线程池进一步池化，并每次随机选择一个连接池来获取连接。  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">g_pools = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    g_pools.append(PooledDB(MySQLdb,</span><br><span class="line">                            mincached=<span class="number">3</span>,</span><br><span class="line">                            host=<span class="string">"aaa.bbb.ccc.ddd"</span>,</span><br><span class="line">                            user=<span class="string">"xxxx"</span>,</span><br><span class="line">                            passwd=<span class="string">"yyyy"</span>,</span><br><span class="line">                            port=<span class="number">3306</span>,</span><br><span class="line">                            db=<span class="string">"dbname"</span>,)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> random</span><br><span class="line">    pool = random.sample(g_pools, <span class="number">1</span>)</span><br><span class="line">    conn = pool.connection()</span><br><span class="line">    cursor = conn.cursor(MySQLdb.cursors.DictCursor)</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、内存调优"><a href="#二、内存调优" class="headerlink" title="二、内存调优"></a>二、内存调优</h2><h3 id="2-1-Python-内存管理机制"><a href="#2-1-Python-内存管理机制" class="headerlink" title="2.1 Python 内存管理机制"></a>2.1 Python 内存管理机制</h3><p>Python 的内存管理主要是基于 3 种机制：</p>
<ul>
<li>引用计数。<ul>
<li>当引用计数为 0 时，对象将会被立即回收。</li>
</ul>
</li>
<li>垃圾回收。<ul>
<li>Python 中将会有个双向链表来记录所有生成的对象（被这个链表所引用并不会增加引用计数，可以认为这个链表弱引用了对象）。</li>
<li>当对象个数达到一定的限度，则会启动 gc 垃圾回收，gc 会遍历所有对象，并判断对象是否仍然可达，具体的判断方式可以参考<a href="http://arctrix.com/nas/python/gc/" target="_blank" rel="noopener">Garbage Collection for Python</a>。</li>
<li>在进行 gc 时，整个 Python 进程都会停止下来，等待垃圾回收完成。</li>
</ul>
</li>
<li>分代机制。<ul>
<li>Python 将对象分为三代：0、1、2。</li>
<li>当进行回收时，若对象可达，对象将不会被回收，并且会被放入下一代。</li>
<li>每次 gc 都会对 0 代进行，当 0 代的回收达到一定次数，才会进行 1 代的回收，当 1 代的回收达到一定的次数，才会进行 2 代的回收。</li>
<li>分代机制的思想是认为短期生成的对象被回收的可能性大于生命周期长的对象，因此通过这个方式降低对长周期对象的回收频率，减少每次 gc 回收时所需要遍历的对象，提升性能。</li>
</ul>
</li>
</ul>
<p>Python 的内存回收机制存在下述问题，需要特别注意：</p>
<ul>
<li>循环依赖问题<ul>
<li>从上述机制中可以看到，垃圾回收<code>只针对</code>循环依赖的对象，并且垃圾回收会非常影响性能，因此需要避免。</li>
<li>当循环依赖的对象中，如果实现了 <code>__del__</code> 方法，则对象无法被垃圾回收，这是因为 Python 不知道优先执行哪个对象的 <code>__del__</code> 方法，因此放弃进行垃圾回收。</li>
</ul>
</li>
<li>内存泄漏问题<ul>
<li><code>如果禁用了垃圾回收</code>，则循环依赖将会导致内存泄漏。</li>
<li>循环依赖的对象实现了 <code>__del__</code> 方法。</li>
<li>短生命周期的对象被无意中被长生命周期的对象持有，导致没有被释放。</li>
</ul>
</li>
</ul>
<h3 id="2-2-gc-模块"><a href="#2-2-gc-模块" class="headerlink" title="2.2 gc 模块"></a>2.2 gc 模块</h3><p>gc 模块给程序员提供了控制 Python 垃圾回收的相关能力，</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动和禁用垃圾回收</span></span><br><span class="line">gc.enable()</span><br><span class="line">gc.disable()</span><br><span class="line">gc.isenabled()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发垃圾回收</span></span><br><span class="line"><span class="comment"># 参数为 2 （默认值），会触发一次完整的垃圾回收</span></span><br><span class="line">gc.collect(generation=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置垃圾收集器的调试标识, 需要注意 Python2 和 Python3 的 标识是不一样的</span></span><br><span class="line">gc.set_debug(flag)</span><br><span class="line">gc.get_debug()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置和获取垃圾回收阈值</span></span><br><span class="line"><span class="comment"># threshold0 - 当分配的对象数量减去释放掉的对象数量超过该阈值，则会触发 0 代的垃圾回收，如果值为 0 将会禁止掉垃圾回收</span></span><br><span class="line"><span class="comment"># threshold1 - 当 0 代的垃圾回收次数超过该阈值，则触发对 1 代的垃圾回收。</span></span><br><span class="line"><span class="comment"># threshold2 - 当 1 代的垃圾回收次数超过该阈值，则触发对 2 代的垃圾回收。</span></span><br><span class="line">gc.set_threshold(threshold0 [，threshold1 [，threshold2 ] ])</span><br><span class="line">gc.get_threshold()</span><br></pre></td></tr></table></figure>
<p>通过 gc 库判断某段代码是否存在循环依赖<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">py2</span><span class="params">()</span>:</span></span><br><span class="line">    gc.disable()</span><br><span class="line">    gc.set_debug(gc.DEBUG_COLLECTABLE | gc.DEBUG_UNCOLLECTABLE | gc.DEBUG_OBJECTS)</span><br><span class="line">    test()</span><br><span class="line">    gc.collect()</span><br><span class="line">    <span class="comment"># 如果存在循环依赖，则会输出至 stderr</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">py3</span><span class="params">()</span>:</span></span><br><span class="line">    gc.disable()</span><br><span class="line">    gc.set_debug(gc.DEBUG_SAVEALL)</span><br><span class="line">    test()</span><br><span class="line">    gc.collect()</span><br><span class="line">    <span class="comment"># 如果 gc.garbage 中存在对象，则意味着存在循环依赖。</span></span><br><span class="line">    print(gc.garbage)</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，python2 和 python3 的接口使用方式略有差别。</p>
<p>Python 执行垃圾回收的时机：</p>
<ul>
<li>达到了垃圾回收的阈值，Python虚拟机自动执行。</li>
<li>手动调用gc.collect()</li>
<li>Python虚拟机退出的时候</li>
</ul>
<h3 id="2-3-tracemalloc"><a href="#2-3-tracemalloc" class="headerlink" title="2.3 tracemalloc"></a>2.3 tracemalloc</h3><p>通过 gc 库，可以让我们知道是否存在内存增长，但是并不能让我们知道到底是什么原因导致的内存增长。Python 3.4 后，内置了 tracemalloc 库，该库提供以下能力：</p>
<ul>
<li>定位内存的分配。</li>
<li>检测两个内存快照之间的差异，以检测内存泄漏。</li>
<li>统计每行代码的内存分配信息，包括：该行内存分配的总大小，分配内存的次数，以及平均每次分配的大小。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tracemalloc_test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tracemalloc</span><br><span class="line"></span><br><span class="line">g_cached = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waste_memory</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        g_cached[i] = MyObject()</span><br><span class="line">    g_cached[<span class="string">"obj"</span>] = MyObject()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    waste_memory()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    nframe = <span class="number">10</span></span><br><span class="line">    tracemalloc.start(nframe)</span><br><span class="line">    snapshot1 = tracemalloc.take_snapshot()</span><br><span class="line">    main()</span><br><span class="line">    snapshot2 = tracemalloc.take_snapshot()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># top_stats = snapshot2.compare_to(snapshot1, 'lineno')</span></span><br><span class="line">    top_stats = snapshot2.compare_to(snapshot1, <span class="string">'traceback'</span>)</span><br><span class="line">    print(<span class="string">"[ Top 10 differences ]"</span>)</span><br><span class="line">    <span class="keyword">for</span> stat <span class="keyword">in</span> top_stats[:<span class="number">10</span>]:</span><br><span class="line">        print(stat)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印分配内存最多的栈信息，以定位是哪部分的代码触发内存增长</span></span><br><span class="line">    stat = top_stats[<span class="number">0</span>]</span><br><span class="line">    print(<span class="string">"\ntop 1 allocate %s memory blocks: %.1f KiB"</span> % (stat.count, stat.size / <span class="number">1024</span>))</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> stat.traceback.format():</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure>
<p>上述代码在 <code>waste_memory()</code> 函数中分配自定义类型的对象，并被全局字典所持有。通过 tracemalloc 可以打印对内存分配进行定位，甚至打印出内存分配点的栈信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ python tracemalloc_test.py</span><br><span class="line">[ Top 10 differences ]</span><br><span class="line">tracemalloc_test.py:13: size=10232 B (+10232 B), count=101 (+101), average=101 B</span><br><span class="line">tracemalloc_test.py:17: size=448 B (+448 B), count=1 (+1), average=448 B</span><br><span class="line">/home/user00/bin/python3/lib/python3.6/tracemalloc.py:387: size=96 B (+96 B), count=2 (+2), average=48 B</span><br><span class="line">tracemalloc_test.py:14: size=56 B (+56 B), count=1 (+1), average=56 B</span><br><span class="line">/home/user00/bin/python3/lib/python3.6/tracemalloc.py:524: size=56 B (+56 B), count=1 (+1), average=56 B</span><br><span class="line">/home/user00/bin/python3/lib/python3.6/tracemalloc.py:281: size=40 B (+40 B), count=1 (+1), average=40 B</span><br><span class="line"></span><br><span class="line">top 1 allocate 101 memory blocks: 10.0 KiB</span><br><span class="line">  File <span class="string">"tracemalloc_test.py"</span>, line 13</span><br><span class="line">    g_cached[i] = MyObject()</span><br><span class="line">  File <span class="string">"tracemalloc_test.py"</span>, line 17</span><br><span class="line">    waste_memory()</span><br><span class="line">  File <span class="string">"tracemalloc_test.py"</span>, line 24</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>如果已知一个对象，也可以通过 tracemalloc 模块定位该对象的内存分配位置，这有助于定位导致循环依赖的代码，下面是一个循环依赖的定位例子：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tracemalloc</span><br><span class="line"><span class="keyword">import</span> gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    a = MyObject()</span><br><span class="line">    b = MyObject()</span><br><span class="line">    a.child = b</span><br><span class="line">    b.child = a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    gc.disable()</span><br><span class="line">    gc.collect()</span><br><span class="line">    gc.set_debug(gc.DEBUG_SAVEALL)</span><br><span class="line">    tracemalloc.start(<span class="number">10</span>)</span><br><span class="line">    main()</span><br><span class="line">    gc.collect()</span><br><span class="line">    print(<span class="string">"unreachable objects :"</span>)</span><br><span class="line">    <span class="keyword">for</span> o <span class="keyword">in</span> gc.garbage:</span><br><span class="line">        print(o)</span><br><span class="line">    traceback = tracemalloc.get_object_traceback(gc.garbage[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"\nunreachable object allocate traceback: "</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> traceback.format():</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure></p>
<p>上述的例子是生成一个循环依赖，然后通过 gc.garbage 来记录循环依赖的对象，再通过 tracemalloc 来定位对象的分配位置。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line">unreachable objects :</span><br><span class="line">&lt;__main__.MyObject object at 0x7f314b9a7d68&gt;</span><br><span class="line">&lt;__main__.MyObject object at 0x7f314b95d3c8&gt;</span><br><span class="line">&#123;<span class="string">'child'</span>: &lt;__main__.MyObject object at 0x7f314b95d3c8&gt;&#125;</span><br><span class="line">&#123;<span class="string">'child'</span>: &lt;__main__.MyObject object at 0x7f314b9a7d68&gt;&#125;</span><br><span class="line"></span><br><span class="line">unreachable object allocate traceback:</span><br><span class="line">  File <span class="string">"test.py"</span>, line 10</span><br><span class="line">    a = MyObject()</span><br><span class="line">  File <span class="string">"test.py"</span>, line 21</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>关于 tracemalloc 更多的更能，参考<a href="https://docs.python.org/3.8/library/tracemalloc.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="2-4-objgraph"><a href="#2-4-objgraph" class="headerlink" title="2,4 objgraph"></a>2,4 objgraph</h3><p>tracemalloc 可以非常好的定位出对象的分配情况，但是 tracemalloc 只在 Python 3.4 以后的版本才能使用，并且对于循环依赖的场景 tracemalloc 输出的结果仍然不足够直观。</p>
<h3 id="2-5-优化手段"><a href="#2-5-优化手段" class="headerlink" title="2.5 优化手段"></a>2.5 优化手段</h3><ul>
<li>因为 gc 会引起 stop the world，因此需要尽量避免触发 gc<ul>
<li>尽量避免使用循环依赖（循环依赖链中的对象过多，将会触发 gc）</li>
<li>性能敏感的场景可以禁止系统自动 gc，由程序员选择在适当的时候触发 gc。</li>
<li>调整垃圾回收的阈值，避免一次性的大量临时对象的创建触发 gc。过大的阈值可能会导致一次 gc 的耗时非常久。</li>
<li>使用弱引用。</li>
</ul>
</li>
</ul>
<h2 id="三、定位正在运行的-Python-进程"><a href="#三、定位正在运行的-Python-进程" class="headerlink" title="三、定位正在运行的 Python 进程"></a>三、定位正在运行的 Python 进程</h2><p>前述的工具都需要从头开始运行 Python 脚本，对于已经处于运行状态的 Python 的性能定位，则需要借助其他工具。</p>
<h3 id="3-1-pstack"><a href="#3-1-pstack" class="headerlink" title="3.1 pstack"></a>3.1 pstack</h3><p>pstack 命令可显示每个进程的栈跟踪，这在 Python 的问题定位中同样适用，方便检测 Python 在哪个位置挂起。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(tid, lock)</span>:</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        delay()</span><br><span class="line">        <span class="keyword">with</span> lock:</span><br><span class="line">            print(<span class="string">"tid: "</span>, tid, <span class="string">", idx: "</span>, idx)</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    t1 = threading.Thread(target=process, args=(<span class="number">1</span>, lock))</span><br><span class="line">    t2 = threading.Thread(target=process, args=(<span class="number">2</span>, lock))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>
<p>代码的逻辑非常简单，主线程开启两个线程，线程循环每秒打印信息，主线成等待子线程结束。我们可以通过 pstack 查看进程的运行栈：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">$ pstack &lt;pid&gt;</span><br><span class="line">Thread 3 (Thread 0x7f0f99618700 (LWP 13467)):</span><br><span class="line"><span class="comment">#0  0x00007f0fa065dbd3 in select () from /lib64/libc.so.6</span></span><br><span class="line"><span class="comment">#1  0x00007f0f99e42070 in time_sleep () from /usr/lib64/python2.7/lib-dynload/timemodule.so</span></span><br><span class="line"><span class="comment">#2  0x00007f0fa1339af0 in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#3  0x00007f0fa13394bd in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#4  0x00007f0fa133be3d in PyEval_EvalCodeEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#5  0x00007f0fa12c588d in function_call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#6  0x00007f0fa12a08e3 in PyObject_Call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#7  0x00007f0fa13344fd in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#8  0x00007f0fa13394bd in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#9  0x00007f0fa13394bd in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#10 0x00007f0fa133be3d in PyEval_EvalCodeEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#11 0x00007f0fa12c5798 in function_call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#12 0x00007f0fa12a08e3 in PyObject_Call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#13 0x00007f0fa12af8d5 in instancemethod_call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#14 0x00007f0fa12a08e3 in PyObject_Call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#15 0x00007f0fa13326f7 in PyEval_CallObjectWithKeywords () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#16 0x00007f0fa136a5c2 in t_bootstrap () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#17 0x00007f0fa1040dc5 in start_thread () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#18 0x00007f0fa066676d in clone () from /lib64/libc.so.6</span></span><br><span class="line">Thread 2 (Thread 0x7f0f98e17700 (LWP 13468)):</span><br><span class="line"><span class="comment">#0  0x00007f0fa065dbd3 in select () from /lib64/libc.so.6</span></span><br><span class="line"><span class="comment">#1  0x00007f0f99e42070 in time_sleep () from /usr/lib64/python2.7/lib-dynload/timemodule.so</span></span><br><span class="line"><span class="comment">#2  0x00007f0fa1339af0 in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#3  0x00007f0fa13394bd in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#4  0x00007f0fa133be3d in PyEval_EvalCodeEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#5  0x00007f0fa12c588d in function_call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#6  0x00007f0fa12a08e3 in PyObject_Call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#7  0x00007f0fa13344fd in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#8  0x00007f0fa13394bd in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#9  0x00007f0fa13394bd in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#10 0x00007f0fa133be3d in PyEval_EvalCodeEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#11 0x00007f0fa12c5798 in function_call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#12 0x00007f0fa12a08e3 in PyObject_Call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#13 0x00007f0fa12af8d5 in instancemethod_call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#14 0x00007f0fa12a08e3 in PyObject_Call () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#15 0x00007f0fa13326f7 in PyEval_CallObjectWithKeywords () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#16 0x00007f0fa136a5c2 in t_bootstrap () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#17 0x00007f0fa1040dc5 in start_thread () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#18 0x00007f0fa066676d in clone () from /lib64/libc.so.6</span></span><br><span class="line">Thread 1 (Thread 0x7f0fa1834740 (LWP 13466)):</span><br><span class="line"><span class="comment">#0  0x00007f0fa104679b in do_futex_wait.constprop.1 () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#1  0x00007f0fa104682f in __new_sem_wait_slow.constprop.0 () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#2  0x00007f0fa10468cb in sem_wait@@GLIBC_2.2.5 () from /lib64/libpthread.so.0</span></span><br><span class="line"><span class="comment">#3  0x00007f0fa1366535 in PyThread_acquire_lock () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#4  0x00007f0fa136a1c2 in lock_PyThread_acquire_lock () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#5  0x00007f0fa1339af0 in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#6  0x00007f0fa133be3d in PyEval_EvalCodeEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#7  0x00007f0fa133933c in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#8  0x00007f0fa133be3d in PyEval_EvalCodeEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#9  0x00007f0fa133933c in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#10 0x00007f0fa13394bd in PyEval_EvalFrameEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#11 0x00007f0fa133be3d in PyEval_EvalCodeEx () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#12 0x00007f0fa133bf42 in PyEval_EvalCode () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#13 0x00007f0fa135537f in run_mod () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#14 0x00007f0fa135653e in PyRun_FileExFlags () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#15 0x00007f0fa13577c9 in PyRun_SimpleFileExFlags () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#16 0x00007f0fa136891f in Py_Main () from /lib64/libpython2.7.so.1.0</span></span><br><span class="line"><span class="comment">#17 0x00007f0fa0590b35 in __libc_start_main () from /lib64/libc.so.6</span></span><br><span class="line"><span class="comment">#18 0x000000000040071e in _start ()</span></span><br></pre></td></tr></table></figure></p>
<p>可以看出有两个线程组塞在 time_sleep 上，而有一个线程组塞在了信号量上。虽然通过 pstack 可以比较直观的看到当前的 Python 解释器栈，也可以比较方便的定位系统调用导致的组塞，但是这并不方便我们观察当前线程具体组塞到了 Python 的哪个代码段。</p>
<h3 id="3-2-打印-Python-栈信息"><a href="#3-2-打印-Python-栈信息" class="headerlink" title="3.2 打印 Python 栈信息"></a>3.2 打印 Python 栈信息</h3><p>虽然 pstack 已经足够好用，可以打印进程中每个线程的栈信息，但是显示的栈信息并非是 Python 代码的栈，而是 Python 解释器底层 C 代码的栈。</p>
<p>为了更直观的显示 Python 的栈信息，可以注册一个信号，用来打印栈信息（如果您有更好的方法，请您能告诉我，非常感谢）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_stack</span><span class="params">(signum, frame)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"\n*** STACKTRACE - START ***\n"</span>)</span><br><span class="line">    <span class="keyword">for</span> th <span class="keyword">in</span> threading.enumerate():</span><br><span class="line">        print(th)</span><br><span class="line">        traceback.print_stack(sys._current_frames()[th.ident])</span><br><span class="line">        print(<span class="string">"\n"</span>)</span><br><span class="line">    print(<span class="string">"\n*** STACKTRACE - END ***\n"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(tid, lock)</span>:</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        delay()</span><br><span class="line">        <span class="keyword">with</span> lock:</span><br><span class="line">            print(<span class="string">"tid: "</span>, tid, <span class="string">", idx: "</span>, idx)</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    signal.signal(signal.SIGUSR1, print_stack)</span><br><span class="line">    lock = threading.Lock()</span><br><span class="line">    t1 = threading.Thread(target=process, args=(<span class="number">1</span>, lock))</span><br><span class="line">    t2 = threading.Thread(target=process, args=(<span class="number">2</span>, lock))</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>代码非常简单，逻辑和 pstack 的测试代码完全一致，只是在初始时注册了 SIGUSR1 的信号处理器，当进程接收到  SIGUSR1 信号，将会打印所有线程的栈信息:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py &amp;</span><br><span class="line">$ <span class="built_in">kill</span> -USR1 &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 test.py 的标准输出中将会打印：</span></span><br><span class="line">*** STACKTRACE - START ***</span><br><span class="line"></span><br><span class="line">&lt;_MainThread(MainThread, started 140318992144192)&gt;</span><br><span class="line">  File <span class="string">"test.py"</span>, line 46, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    main()</span><br><span class="line">  File <span class="string">"test.py"</span>, line 42, <span class="keyword">in</span> main</span><br><span class="line">    t1.join()</span><br><span class="line">  File <span class="string">"/usr/local/python3/lib/python3.6/threading.py"</span>, line 1056, <span class="keyword">in</span> join</span><br><span class="line">    self._wait_for_tstate_lock()</span><br><span class="line">  File <span class="string">"/usr/local/python3/lib/python3.6/threading.py"</span>, line 1072, <span class="keyword">in</span> _wait_for_tstate_lock</span><br><span class="line">    <span class="keyword">elif</span> lock.acquire(block, timeout):</span><br><span class="line">  File <span class="string">"test.py"</span>, line 15, <span class="keyword">in</span> print_stack</span><br><span class="line">    traceback.print_stack(sys._current_frames()[th.ident])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Thread(Thread-1, started 140318867453696)&gt;</span><br><span class="line">  File <span class="string">"/usr/local/python3/lib/python3.6/threading.py"</span>, line 884, <span class="keyword">in</span> _bootstrap</span><br><span class="line">    self._bootstrap_inner()</span><br><span class="line">  File <span class="string">"/usr/local/python3/lib/python3.6/threading.py"</span>, line 916, <span class="keyword">in</span> _bootstrap_inner</span><br><span class="line">    self.run()</span><br><span class="line">  File <span class="string">"/usr/local/python3/lib/python3.6/threading.py"</span>, line 864, <span class="keyword">in</span> run</span><br><span class="line">    self._target(*self._args, **self._kwargs)</span><br><span class="line">  File <span class="string">"test.py"</span>, line 27, <span class="keyword">in</span> process</span><br><span class="line">    delay()</span><br><span class="line">  File <span class="string">"test.py"</span>, line 21, <span class="keyword">in</span> delay</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Thread(Thread-2, started 140318859060992)&gt;</span><br><span class="line">  File <span class="string">"/usr/local/python3/lib/python3.6/threading.py"</span>, line 884, <span class="keyword">in</span> _bootstrap</span><br><span class="line">    self._bootstrap_inner()</span><br><span class="line">  File <span class="string">"/usr/local/python3/lib/python3.6/threading.py"</span>, line 916, <span class="keyword">in</span> _bootstrap_inner</span><br><span class="line">    self.run()</span><br><span class="line">  File <span class="string">"/usr/local/python3/lib/python3.6/threading.py"</span>, line 864, <span class="keyword">in</span> run</span><br><span class="line">    self._target(*self._args, **self._kwargs)</span><br><span class="line">  File <span class="string">"test.py"</span>, line 27, <span class="keyword">in</span> process</span><br><span class="line">    delay()</span><br><span class="line">  File <span class="string">"test.py"</span>, line 21, <span class="keyword">in</span> delay</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** STACKTRACE - END ***</span><br></pre></td></tr></table></figure>
<p>需要注意，这段代码在 Python 3.4 前的版本是无法运行起来的，这是一个 Python 的遗留 bug：由于 Thread.join() 组塞的主线程，是无法响应信号的。</p>
<p>因此在老版本的 Python 测试该例子，可以用主线成循环 sleep 代替 join。</p>
<h3 id="3-3-python-gdb"><a href="#3-3-python-gdb" class="headerlink" title="3.3 python-gdb"></a>3.3 python-gdb</h3><p>gdb 通过配置可以支持调试运行中的 Python 进程，具体可以参考<a href="https://wiki.python.org/moin/DebuggingWithGdb" target="_blank" rel="noopener">DebuggingWithGdb</a></p>
<h2 id="附录、参考文献"><a href="#附录、参考文献" class="headerlink" title="附录、参考文献"></a>附录、参考文献</h2><ul>
<li><a href="">[1] 编写高质量代码 改善Python程序的91个建议</a></li>
<li><a href="">[2] Effective Python</a></li>
<li><a href="">[3] profile</a></li>
<li><a href="https://docs.python.org/3/library/gc.html" target="_blank" rel="noopener">[4] Garbage Collector interface</a></li>
<li><a href="https://mg.pov.lt/objgraph/index.html" target="_blank" rel="noopener">[5] objgraph</a></li>
<li><a href="https://docs.python.org/3.8/library/tracemalloc.html" target="_blank" rel="noopener">[6] tracemalloc - Trace memory allocations</a></li>
<li><a href="http://kkpattern.github.io/2015/06/20/python-memory-optimization-zh.html" target="_blank" rel="noopener">[7] Python内存管理机制及优化简析</a></li>
<li><a href="https://www.cnblogs.com/xybaby/p/7491656.html#_label_4" target="_blank" rel="noopener">[8] 使用gc、objgraph干掉python内存泄露与循环引用!</a></li>
<li><a href="https://www.cnblogs.com/xybaby/p/7488216.html" target="_blank" rel="noopener">[9] Python内存优化：Profile，slots，compact dict</a></li>
<li><a href="https://wiki.python.org/moin/DebuggingWithGdb" target="_blank" rel="noopener">[10] DebuggingWithGdb</a></li>
<li><a href="https://www.cnblogs.com/xybaby/p/8025435.html" target="_blank" rel="noopener">[11] 啊，我的程序为啥卡住啦</a></li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Arthur Lu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://github.com/lsj9383/2020/04/29/Python-优化/">http://github.com/lsj9383/2020/04/29/Python-优化/</a></span>
                    </p>
                
                <!-- 
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                 -->
                <!-- 
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</span>
                     </p>
                 -->

            </section>
        
        <!-- <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section> -->
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2020/03/30/Nginx-SSL证书配置/">Nginx SSL证书配置</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Arthur Lu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a></span>
    </div>
</footer>

    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
