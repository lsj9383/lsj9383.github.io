<!DOCTYPE html>
<html lang="en">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="description" content="其实不过是杂记">



<title>DBUtils In Python | 小记</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    



    
    
        
    


</head>
<body class="dark-theme">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">小记</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input hidden id="switch_default" type="checkbox" class="switch_default">
                <label style="display:none" for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">小记</a><a id="mobile-toggle-theme">·&nbsp;Dark</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">DBUtils In Python</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Arthur Lu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">January 2, 2019&nbsp;&nbsp;17:34:49</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>本文对 PEP 249、数据库连接池以及 MySQL 客户端驱动相关的问题进行了梳理。</p>
<p>本文列出的源码均不是真实的源码，而是进行整理、删减后的伪代码，如此更能突出机制和原理。</p>
<h2 id="二、DB-API-2"><a href="#二、DB-API-2" class="headerlink" title="二、DB-API 2"></a>二、DB-API 2</h2><p>DB-API 2 就是满足 <a href="https://www.python.org/dev/peps/pep-0249/" target="_blank" rel="noopener">PEP 249</a> 规范的数据库模块。</p>
<p>PEP 249 规范描述了以下接口：</p>
<ul>
<li>如何生成数据库连接和游标</li>
<li>数据库连接和游标对象的接口</li>
<li>模块、数据库连接和数据库游标的相关属性</li>
<li>其他扩展</li>
</ul>
<p>PEP 249 为 Python 应用程序访问数据库提供了统一的接口，结构如下：</p>
<p><img src="PEP249.png" alt=""></p>
<p>PEP 249 提供的相关接口：</p>
<ul>
<li><p>DB-API 2 模块</p>
<ul>
<li><p>创建连接</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnx = connect( parameters... )</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块变量</p>
<ul>
<li>apilevel, 表示 dbapi 级别：<ul>
<li><code>&quot;1.0&quot;</code>，模块 DB-API 满足 PEP 248 规范。</li>
<li><code>&quot;2.0&quot;</code>，模块 DB-API 满足 PEP 249 规范。</li>
</ul>
</li>
<li><p>threadsafety，表示模块和相关对象的线程安全级别：</p>
<p>  threadsafety|Meaning<br>  -|-<br>  0|module（DB-API 2 模块）无法在多个线程间共享。<br>  1|module 可以多线程之间共享，connection （数据库连接）不能在多个线程之间共享。<br>  2|module 和 connection 都能在多个线程间共享。<br>  3|module、connection 和 cursor（数据库游标）可以在多个线程间共享。</p>
</li>
<li><p>paramstyle，模块接口期望的参数标记(parameter marker)的格式化风格</p>
<p>  paramstyle|Meaning<br>  -|-<br>  qmark|Question mark style, e.g. …WHERE name=?<br>  numeric|Numeric, positional style, e.g. …WHERE name=:1<br>  named|Named style, e.g. …WHERE name=:name<br>  format|ANSI C printf format codes, e.g. …WHERE name=%s<br>  pyformat|Python extended format codes, e.g. …WHERE name=%(name)s</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Exception 结构</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StandardError</span><br><span class="line">|__Warning</span><br><span class="line">|__Error</span><br><span class="line">|__InterfaceError</span><br><span class="line">|__DatabaseError</span><br><span class="line">    |__DataError</span><br><span class="line">    |__OperationalError</span><br><span class="line">    |__IntegrityError</span><br><span class="line">    |__InternalError</span><br><span class="line">    |__ProgrammingError</span><br><span class="line">    |__NotSupportedError</span><br></pre></td></tr></table></figure>
</li>
<li><p>connection 对象</p>
<ul>
<li><code>connection.close()</code></li>
<li><code>connection.commit()</code></li>
<li><code>connection.rollback()</code></li>
<li><code>connection.cursor()</code></li>
</ul>
</li>
<li>cursor 对象<ul>
<li>cursor 属性<ul>
<li><code>cursor.description</code>，返回 SELECT 语句执行后的列信息：<ul>
<li>返回的是一个数组，数组中的每个元素是一个列信息，顺序按 SELECT 返回的顺序。</li>
<li>列信息用一个 tuple 进行表示，具体可参考 <a href="https://www.python.org/dev/peps/pep-0249/#cursor-attributes" target="_blank" rel="noopener">Cursor attributes</a>。</li>
</ul>
</li>
<li><code>cursor.rowcount</code><ul>
<li>对于 INSERT &amp; UPDATE &amp; DELETE 语句而言，代表影响的行数。</li>
<li>对于 SELECT 语句而言，代表数据集的行数。</li>
</ul>
</li>
<li><code>cursor.arraysize</code>，fetchmany 执行时的默认 size。</li>
</ul>
</li>
<li>cursor 方法<ul>
<li><code>cursor.callproc( procname [, parameters ] )</code></li>
<li><code>cursor.close()</code></li>
<li><code>cursor.execute(operation [, parameters])</code></li>
<li><code>cursor.executemany( operation, seq_of_parameters )</code></li>
<li><code>cursor.fetchone()</code></li>
<li><code>cursor.fetchmany([size=cursor.arraysize])</code></li>
<li><code>cursor.fetchall()</code></li>
<li><code>cursor.nextset()</code></li>
<li><code>cursor.setinputsizes(sizes)</code></li>
<li><code>cursor.setoutputsize(size [, column])</code></li>
</ul>
</li>
</ul>
</li>
<li>可选的扩展<ul>
<li><code>cursor.rownumber</code>，当前获取数据所处的下标。</li>
<li><code>cursor.connection</code></li>
<li><code>cursor.scroll(value [, mode=&#39;relative&#39; ])</code>，cursor 滚动到固定的偏移量进行获取数据。</li>
<li><code>cursor.messages</code>，记录错误和告警信息。</li>
<li><code>connection.messages</code>，和 <code>cursor.message</code> 类似，信息是面向连接的。</li>
<li><code>cursor.next()</code></li>
<li><code>cursor.__iter__()</code></li>
<li><code>cursor.lastrowid</code>，最后一次修改行的rowid，通常在 INSERT 后获得自增主键的值。</li>
</ul>
</li>
<li>类型对象和构造器</li>
<li>其他扩展<ul>
<li>Exception 扩展</li>
<li>二阶段提交扩展</li>
</ul>
</li>
</ul>
<h2 id="三、DBUtils"><a href="#三、DBUtils" class="headerlink" title="三、DBUtils"></a>三、DBUtils</h2><p>DBUtils 为符合 DB-API 2 的模块提供了连接池化的能力，并且对数据库连接提供了多层封装，提高数据库连接的可用性。</p>
<h3 id="3-1-UML-类图"><a href="#3-1-UML-类图" class="headerlink" title="3.1 UML 类图"></a>3.1 UML 类图</h3><h4 id="3-1-1-SimplePooledDB"><a href="#3-1-1-SimplePooledDB" class="headerlink" title="3.1.1 SimplePooledDB"></a>3.1.1 SimplePooledDB</h4><ul>
<li>线程专用数据库连接</li>
</ul>
<p><img src="SimplePooledDB-Dedicated.png" alt=""></p>
<ul>
<li>线程共享数据库连接</li>
</ul>
<p><img src="SimplePooledDB-Shared.png" alt=""></p>
<h4 id="3-1-2-PersistentDB"><a href="#3-1-2-PersistentDB" class="headerlink" title="3.1.2 PersistentDB"></a>3.1.2 PersistentDB</h4><p><img src="PersistentDB.png" alt=""></p>
<h4 id="3-1-3-PooledDB"><a href="#3-1-3-PooledDB" class="headerlink" title="3.1.3 PooledDB"></a>3.1.3 PooledDB</h4><ul>
<li>线程专用数据库连接</li>
</ul>
<p><img src="PooledDB-Dedicated.png" alt=""></p>
<ul>
<li>线程共享数据库连接</li>
</ul>
<p><img src="PooledDB-Shared.png" alt=""></p>
<h3 id="3-2-SimplePooledDB-PooledDB"><a href="#3-2-SimplePooledDB-PooledDB" class="headerlink" title="3.2 SimplePooledDB.PooledDB"></a>3.2 SimplePooledDB.PooledDB</h3><p>简单的数据库连接池，只提供固定连接个数的连接池，生产环境通常不会使用该类。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SimplePooledDB.PooledDB</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDB</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">            dbapi,                 # 满足 PEP <span class="number">249</span> 的模块</span></span></span><br><span class="line"><span class="function"><span class="params">            maxconnections,        # 最大连接个数</span></span></span><br><span class="line"><span class="function"><span class="params">            *args, **kwargs)</span>:</span>      <span class="comment"># db-api 2 建立连接的参数集</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># 初始化所有的连接</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(maxconnections):</span><br><span class="line">            self.addConnection(dbapi.connect(*args, **kwargs))</span><br></pre></td></tr></table></figure>
<h4 id="3-2-1-PooledDBConnection"><a href="#3-2-1-PooledDBConnection" class="headerlink" title="3.2.1 PooledDBConnection"></a>3.2.1 PooledDBConnection</h4><p>该类是对数据库连接的包装，用于替换掉数据库连接本身的 <code>.close()</code> 方法。</p>
<p>在调用 close 方法时归还连接，而不是关闭连接。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDBConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pool, con)</span>:</span></span><br><span class="line">        self._con = con             <span class="comment"># 数据库连接</span></span><br><span class="line">        self._pool = pool           <span class="comment"># SimplePooledDB.PooledDB</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._con <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            self._pool.returnConnection(self._con)  <span class="comment"># 归还连接</span></span><br><span class="line">            self._con = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""代理所有的数据库连接操作</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> getattr(self._con, name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""对象被垃圾回收时自动关闭</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.close()</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-Dedicated-Connection"><a href="#3-2-2-Dedicated-Connection" class="headerlink" title="3.2.2 Dedicated Connection"></a>3.2.2 Dedicated Connection</h4><p>当连接的 threadsafety 为 1 时，数据库连接不能在线程间共享，只能由一个线程独占。</p>
<p>使用 Queue 作为连接池的队列结构，并在返回连接时用 <code>PooledDBConnection</code> 包装连接，替换 <code>close()</code> 方法。</p>
<h4 id="3-2-3-Shared-Connection"><a href="#3-2-3-Shared-Connection" class="headerlink" title="3.2.3 Shared Connection"></a>3.2.3 Shared Connection</h4><p>当连接的 threadsafety 为 2 或 3 时，连接池可以在线程之间共享。</p>
<p>连接池使用 List 存放所有的连接，并在返回连接时用 <code>PooledDBConnection</code> 包装连接，替换 <code>close()</code> 方法。</p>
<p>通过轮训 List 里面的所有连接来获取连接。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDB</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_threadsafe_get_connection</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next = self._nextConnection</span><br><span class="line">            <span class="comment"># 连接仍然在 List 中，并未取出</span></span><br><span class="line">            con = PooledDBConnection(self, self._connections[next])</span><br><span class="line">            next += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> next &gt;= len(self._connections):</span><br><span class="line">                next = <span class="number">0</span></span><br><span class="line">            self._nextConnection = next</span><br><span class="line">            <span class="keyword">return</span> con</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._lock.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_threadsafe_return_connection</span><span class="params">(self, con)</span>:</span></span><br><span class="line">        <span class="comment"># 因为连接一直都在 List 中，所以不用归还连接</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-PersistentDB"><a href="#3-3-PersistentDB" class="headerlink" title="3.3 PersistentDB"></a>3.3 PersistentDB</h3><p>PersistentDB 通过 LocalThread 将线程之间的连接进行隔离，具体如下：</p>
<ul>
<li>每个线程首次打开连接都会新建连接，下次重新获取连接会直接复用上次的连接。</li>
<li>连接放置到 LocalThread 中，将不同线程的连接进行隔离。</li>
<li>对连接的关闭不会真正关闭连接。</li>
</ul>
<p>通过 PersistentDB 获得的连接大致是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection = SteadyDBConnection(DBAPI-2-Connection)</span><br></pre></td></tr></table></figure>
<p>其中 SteadyDBConnection 提供更稳定的数据库连接（SteadyDBConnection 的 close 方法不会真正的关闭连接）。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DBUtils.SteadyDB <span class="keyword">import</span> connect</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistentDB</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            self,</span></span></span><br><span class="line"><span class="function"><span class="params">            creator,            # 符合 DB-API <span class="number">2</span> 接口的数据库模块。</span></span></span><br><span class="line"><span class="function"><span class="params">            maxusage=None,      # 当数据库的操作次数达到 maxusage 时，会自动重置连接。maxusage 为 None 或 <span class="number">0</span> 时，不会计算次数。</span></span></span><br><span class="line"><span class="function"><span class="params">            setsession=None,    # 设置一系列的初始 SQL，每当获取一个新的连接，都会先执行这些 SQL 语句。</span></span></span><br><span class="line"><span class="function"><span class="params">            failures=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            ping=<span class="number">1</span>,             # 何时进行 ping 检测的标识。依赖于 DBAPI <span class="number">2</span> Connection 提供的 ping 方法，该方法并不是标准的一部分。</span></span></span><br><span class="line"><span class="function"><span class="params">            closeable=False,    # 对连接调用 close 方法时，是否进行连接的关闭。</span></span></span><br><span class="line"><span class="function"><span class="params">            threadlocal=None,   # 提供线程隔离的 ThreadLocal 对象，默认时采用系统提供的 ThreadLocal 对象。</span></span></span><br><span class="line"><span class="function"><span class="params">            *args, **kwargs)</span>:</span>   <span class="comment"># DB-API 2 创建连接的参数。</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        self._args, self._kwargs = args, kwargs</span><br><span class="line">        self.thread = (threadlocal <span class="keyword">or</span> local)()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">steady_connection</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> connect(</span><br><span class="line">            self._creator, self._maxusage, self._setsession,</span><br><span class="line">            self._failures, self._ping, self._closeable,</span><br><span class="line">            *self._args, **self._kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connection</span><span class="params">(self, shareable=False)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            con = self.thread.connection</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            con = self.steady_connection()</span><br><span class="line">            self.thread.connection = con</span><br><span class="line">        <span class="comment"># 检查连接</span></span><br><span class="line">        con._ping_check()</span><br><span class="line">        <span class="keyword">return</span> con</span><br></pre></td></tr></table></figure>
<p>对于构造函数的 ping 参数，取值和对应的行为：</p>
<ul>
<li>0 = None = 从不进行 ping 校验。</li>
<li>1 = default = 任何获取连接的请求都进行 ping 校验。</li>
<li>2 = 当 cursor 创建时进行 ping 校验。</li>
<li>4 = 当 cursor 进行一次 query 时，进行 ping 校验。</li>
<li>7 = 以上所有操作总是进行 ping 校验。</li>
</ul>
<p>对于 maxusage 参数，以下操作会触使用操作次数递增：</p>
<ul>
<li>获得一个新的 cursor。</li>
<li>cursor 执行 execute 和 call 方法。</li>
</ul>
<p>PersistentDB 只是对线程隔离提供了一层封装，其他功能均是在 SteadyDBConnection 中进行的实现。</p>
<h3 id="3-4-PooledDB"><a href="#3-4-PooledDB" class="headerlink" title="3.4 PooledDB"></a>3.4 PooledDB</h3><p>PooledDB 提供线程安全的数据库连接池，并且支持 dedicated 和 shared 两种机制。</p>
<p>通过 PooledDB 获得的连接大致是这样的：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dedicated</span></span><br><span class="line">connection = PooledDedicatedDBConnection(</span><br><span class="line">                SteadyDBConnection(</span><br><span class="line">                    DBAPI-2-Connection))</span><br><span class="line"></span><br><span class="line"><span class="comment"># shared</span></span><br><span class="line">connection = PooledSharedDBConnection(</span><br><span class="line">                SharedDBConnection(</span><br><span class="line">                    SteadyDBConnection(</span><br><span class="line">                        DBAPI-2-Connection)))</span><br></pre></td></tr></table></figure>
<p>PooledDB 相关函数:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDB</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            self,</span></span></span><br><span class="line"><span class="function"><span class="params">            creator,                    # 符合 DB-API <span class="number">2</span> 接口的数据库模块。</span></span></span><br><span class="line"><span class="function"><span class="params">            mincached=<span class="number">0</span>,                # 最小缓存的连接数, pool 初始化时将会预先建立 mincached 个数的连接。</span></span></span><br><span class="line"><span class="function"><span class="params">            maxcached=<span class="number">0</span>,                # 最大缓存的连接数, pool 的连接个数超过 maxcached 个数的连接后，将会删除多余的连接。<span class="number">0</span> 表示不回收任何连接。</span></span></span><br><span class="line"><span class="function"><span class="params">            maxshared=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            maxconnections=<span class="number">0</span>,           # 连接数上限, <span class="number">0</span> 为不设上限，每当连接达到这个数时，将会阻塞或是抛出异常。shared 机制下，不受该参数影响。</span></span></span><br><span class="line"><span class="function"><span class="params">            blocking=False,             # 连接数量达到 maxconnections 后，再获取连接是否会进行阻塞。</span></span></span><br><span class="line"><span class="function"><span class="params">            maxusage=None,              # 当连接的操作次数达到 maxusage 时，会自动重置连接。maxusage 为 None 或 <span class="number">0</span> 时，不会计算次数。</span></span></span><br><span class="line"><span class="function"><span class="params">            setsession=None,            # 设置一系列的初始 SQL，每当获取一个新的连接，都会先执行这些 SQL 语句</span></span></span><br><span class="line"><span class="function"><span class="params">            reset=True,                 # 连接归还给 pool 时，是否进行重置</span></span></span><br><span class="line"><span class="function"><span class="params">            failures=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            ping=<span class="number">1</span>,                     # 何时进行 ping 检测的标识。依赖于 DBAPI <span class="number">2</span> Connection 提供的 ping 方法，该方法并不是标准的一部分。</span></span></span><br><span class="line"><span class="function"><span class="params">            *args, **kwargs)</span>:</span>           <span class="comment"># DB-API 2 创建连接的参数</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 存放连接池的 List</span></span><br><span class="line">        self._idle_cache = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化连接池</span></span><br><span class="line">        idle = [self.dedicated_connection() <span class="keyword">for</span> i <span class="keyword">in</span> range(mincached)]</span><br><span class="line">        <span class="keyword">while</span> idle:</span><br><span class="line">            idle.pop().close()</span><br></pre></td></tr></table></figure></p>
<p>对于构造函数的 ping 参数，取值和对应的行为：</p>
<ul>
<li>0 = None = 从不进行 ping 校验（如果 connection 不支持 ping，则无论 ping 设置为何值，都会退化为 ping == 0）。</li>
<li>1 = default = 从池中获取连接的请求都进行 ping 校验。</li>
<li>2 = 当 cursor 创建时进行 ping 校验。</li>
<li>4 = 当 cursor 进行一次 query 时，进行 ping 校验。</li>
<li>7 = 以上所有操作总是进行 ping 校验。</li>
</ul>
<p>对于 maxusage 参数，以下操作会触使用操作次数递增：</p>
<ul>
<li>获得一个新的 cursor。</li>
<li>cursor 执行 execute 和 call 方法。</li>
</ul>
<h3 id="3-4-1-Dedicated-和-Shared-机制"><a href="#3-4-1-Dedicated-和-Shared-机制" class="headerlink" title="3.4.1 Dedicated 和 Shared 机制"></a>3.4.1 Dedicated 和 Shared 机制</h3><p>对于 maxshared 参数，用于在 Shared 机制下进行控制，Shared 机制是指的 DB-API 2 Connection 可以在线程之间进行共享时所采用的池化策略。</p>
<p>在构建连接池的时候，就会决定采用 Dedicated 还是 Shared 机制。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDB</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, creator, maxcached=<span class="number">0</span>, ...)</span>:</span></span><br><span class="line">        threadsafety = creator.threadsafety</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> threadsafety &gt; <span class="number">1</span> <span class="keyword">and</span> maxshared:</span><br><span class="line">            self._maxshared = maxshared</span><br><span class="line">            self._shared_cache = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._maxshared = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<p>根据源码，非常明显，threadsafety 为 2 或 3 时，且 maxshared &gt;= 1 时，才会启用 shared 机制，否则强制设置 maxshared = 0。</p>
<h4 id="3-4-1-Dedicated-机制"><a href="#3-4-1-Dedicated-机制" class="headerlink" title="3.4.1 Dedicated 机制"></a>3.4.1 Dedicated 机制</h4><p>Dedicated 机制拿到的连接被 PooledDedicatedDBConnection 包装，该类用于替换掉 close 方法，每当调用 close 方法时归还连接：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDedicatedDBConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pool, con)</span>:</span></span><br><span class="line">        self._con = <span class="keyword">None</span></span><br><span class="line">        self._pool = pool</span><br><span class="line">        self._con = con</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""关闭连接，将连接返回给连接池。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._con:</span><br><span class="line">            self._pool.cache(self._con)</span><br><span class="line">            self._con = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""代理了 SteadyDBConnection 的所有方法。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._con:</span><br><span class="line">            <span class="keyword">return</span> getattr(self._con, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> InvalidConnection</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""引用丢失时，自动触发连接关闭。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.close()</span><br></pre></td></tr></table></figure></p>
<p>非常明显，close 方法的调用会调用 <code>self._pool.cache(self._con)</code>，将连接归还到池中：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDB</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cache</span><span class="params">(self, con)</span>:</span></span><br><span class="line">        <span class="string">"""将 connection 放到连接池中</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._maxcached <span class="keyword">or</span> len(self._idle_cache) &lt; self._maxcached:</span><br><span class="line">                <span class="comment"># 归还到连接池前，先重置连接，重置连接的实现请参考 SteadyDBConnection 的实现</span></span><br><span class="line">                con._reset(force=self._reset)</span><br><span class="line">                self._idle_cache.append(con)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 如果空闲连接个数 &gt;= maxcached，则将多余的连接关闭</span></span><br><span class="line">                con.close()</span><br><span class="line">            self._connections -= <span class="number">1</span></span><br><span class="line">            self._lock.notify()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._lock.release()</span><br></pre></td></tr></table></figure></p>
<p>再来看如何获取连接，获得连接有 3 种方式：</p>
<ul>
<li><code>pooled.steady_connection()</code>，获得 SteadyDBConnection 连接，该连接不受 pooled 管理。</li>
<li><code>pooled.dedicated_connection()</code>，从池内获得专用连接，该连接被 <code>PooledDedicatedDBConnection</code> 包装，会受到 pooled 管理。</li>
<li><code>pooled.connection(shareable=True)</code>，从池内获得一个连接，会根据 <code>maxshared</code> 判断连接是否使用 Shared 机制。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDB</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">steady_connection</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""获得一个独立的 SteadyDBConnection</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> connect(</span><br><span class="line">            self._creator, self._maxusage, self._setsession,</span><br><span class="line">            self._failures, self._ping, <span class="keyword">True</span>, *self._args, **self._kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dedicated_connection</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从池中获得一个 Dedicated Connection</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.connection(<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connection</span><span class="params">(self, shareable=True)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> shareable <span class="keyword">and</span> self._maxshared:</span><br><span class="line">            <span class="comment"># 采用 Shared 机制</span></span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 采用 Dedicated 机制</span></span><br><span class="line">            self._lock.acquire()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 当连接达到 maxconnections，触发 wait_lock()，线程等待（若 blocking == False 会抛出异常）</span></span><br><span class="line">                <span class="keyword">while</span> (self._maxconnections</span><br><span class="line">                        <span class="keyword">and</span> self._connections &gt;= self._maxconnections):</span><br><span class="line">                    self._wait_lock()</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    con = self._idle_cache.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">except</span> IndexError:</span><br><span class="line">                    <span class="comment"># 如果连接为空，则创建一个 SteadyDBConnection</span></span><br><span class="line">                    con = self.steady_connection()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果从池中拿到连接，对连接进行检查（实际是否检查要根据 ping 参数）</span></span><br><span class="line">                    con._ping_check()</span><br><span class="line">                <span class="comment"># 将 SteadyDBConnection 进行包装</span></span><br><span class="line">                con = PooledDedicatedDBConnection(self, con)</span><br><span class="line">                self._connections += <span class="number">1</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self._lock.release()</span><br><span class="line">        <span class="keyword">return</span> con</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_wait_lock</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""当连接个数达到 maxconnections 时，继续获取连接会触发该函数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._blocking:</span><br><span class="line">            <span class="keyword">raise</span> TooManyConnections</span><br><span class="line">        self._lock.wait()</span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-Shared-机制"><a href="#3-4-2-Shared-机制" class="headerlink" title="3.4.2 Shared 机制"></a>3.4.2 Shared 机制</h4><p>Shared 机制拿到的连接被包装：</p>
<ul>
<li>PooledSharedDBConnection，管理对连接的释放，当引用计数为 0 的时候，将连接从 <code>_shared_cache</code> 中移出，并放置到 <code>_idle_cache</code> 中。</li>
<li>SharedDBConnection，提供对 SteadyDBConnection 连接的引用计数，以及根据引用计数进行排序的相关方法。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDB</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connection</span><span class="params">(self, shareable=True)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> shareable <span class="keyword">and</span> self._maxshared:</span><br><span class="line">            <span class="comment"># 触发 Shared 机制</span></span><br><span class="line">            self._lock.acquire()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 如果 shared_cache 缓存为空（无法共享连接），并且当前连接数达到 maxconnections 则进行等待。</span></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">not</span> self._shared_cache <span class="keyword">and</span></span><br><span class="line">                        self._maxconnections <span class="keyword">and</span></span><br><span class="line">                        self._connections &gt;= self._maxconnections):</span><br><span class="line">                    self._wait_lock()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 如果 shared_cache 没有满，则获得一个 SteadyDBConnection，用 SharedDBConnection 包装，并存入 shared_cache</span></span><br><span class="line">                <span class="keyword">if</span> len(self._shared_cache) &lt; self._maxshared:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        con = self._idle_cache.pop(<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">except</span> IndexError:</span><br><span class="line">                        con = self.steady_connection()</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        con._ping_check()  <span class="comment"># check this connection</span></span><br><span class="line">                    con = SharedDBConnection(con)</span><br><span class="line">                    self._connections += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># shared_cache 如果满了，则直接从 shared_cache 中获取连接</span></span><br><span class="line">                    self._shared_cache.sort()</span><br><span class="line">                    con = self._shared_cache.pop(<span class="number">0</span>)</span><br><span class="line">                    <span class="comment"># 如果连接处于事务中，则等待其他连接归还</span></span><br><span class="line">                    <span class="keyword">while</span> con.con._transaction:</span><br><span class="line">                        self._shared_cache.insert(<span class="number">0</span>, con)</span><br><span class="line">                        self._wait_lock()</span><br><span class="line">                        self._shared_cache.sort()</span><br><span class="line">                        con = self._shared_cache.pop(<span class="number">0</span>)</span><br><span class="line">                    <span class="comment"># 检查连接</span></span><br><span class="line">                    con.con._ping_check()</span><br><span class="line">                    <span class="comment"># 增加连接的引用次数</span></span><br><span class="line">                    con.share()</span><br><span class="line">                <span class="comment"># put the connection (back) into the shared cache</span></span><br><span class="line">                self._shared_cache.append(con)</span><br><span class="line">                self._lock.notify()</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self._lock.release()</span><br><span class="line">            con = PooledSharedDBConnection(self, con)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># ...</span></span><br><span class="line">        <span class="keyword">return</span> con</span><br></pre></td></tr></table></figure>
<p><code>_shared_cache</code> 结构存放的是被 <code>SharedDBConnection</code> 包装的 Steady Connection，可以非常方便的获得引用计数最小的共享连接。</p>
<p>SharedDBConnection 的实现：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedDBConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, con)</span>:</span></span><br><span class="line">        self.con = con</span><br><span class="line">        self.shared = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">share</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.shared += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unshare</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.shared -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 其他方法用于连接排序</span></span><br></pre></td></tr></table></figure></p>
<p>PooledSharedDBConnection 的实现：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledDB</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unshare</span><span class="params">(self, con)</span>:</span></span><br><span class="line">        <span class="string">"""减少共享连接的引用，并处理连接所处的缓存</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># SharedDBConnection.unshare()</span></span><br><span class="line">            con.unshare()</span><br><span class="line">            shared = con.shared</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> shared:</span><br><span class="line">                 <span class="comment"># 如果连接没有被共享了，则连接已经空闲，从 shared_cache 中剔除。</span></span><br><span class="line">                self._shared_cache.remove(con)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self._lock.release()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> shared:</span><br><span class="line">            <span class="comment"># connection has become idle, so add it to the idle cache</span></span><br><span class="line">            self.cache(con.con)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledSharedDBConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pool, shared_con)</span>:</span></span><br><span class="line">        self._con = <span class="keyword">None</span></span><br><span class="line">        con = shared_con.con</span><br><span class="line">        self._pool = pool</span><br><span class="line">        self._shared_con = shared_con</span><br><span class="line">        self._con = con</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""关闭连接，触发 unshare，减少共享连接引用，连接应用归零时放置到 _idle_cache</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._con:</span><br><span class="line">            self._pool.unshare(self._shared_con)</span><br><span class="line">            self._shared_con = self._con = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""代理 SteadyDBConnection 的所有方法</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._con:</span><br><span class="line">            <span class="keyword">return</span> getattr(self._con, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> InvalidConnection</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.close()</span><br></pre></td></tr></table></figure></p>
<h3 id="3-5-SteadyDBConnection"><a href="#3-5-SteadyDBConnection" class="headerlink" title="3.5 SteadyDBConnection"></a>3.5 SteadyDBConnection</h3><p>对 DB-API 2 Connection 进行的包装，提供了丰富的功能，包括：</p>
<ul>
<li>对连接的自动检测</li>
<li>连接异常时的处理</li>
<li>请求充实</li>
<li>预置会话</li>
<li>maxusage</li>
</ul>
<h4 id="3-5-1-连接初始化"><a href="#3-5-1-连接初始化" class="headerlink" title="3.5.1 连接初始化"></a>3.5.1 连接初始化</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SteadyDBConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            self,</span></span></span><br><span class="line"><span class="function"><span class="params">            creator,</span></span></span><br><span class="line"><span class="function"><span class="params">            maxusage=None,              # 连接使用 maxusage 后，会进行重启</span></span></span><br><span class="line"><span class="function"><span class="params">            setsession=None,            # 每次获得连接都会先执行 setsession</span></span></span><br><span class="line"><span class="function"><span class="params">            failures=None,</span></span></span><br><span class="line"><span class="function"><span class="params">            ping=<span class="number">1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            closeable=True,             # 连接是否进行关闭（如果不关闭则会进行 reset，即回滚）</span></span></span><br><span class="line"><span class="function"><span class="params">            *args, **kwargs)</span>:</span>           <span class="comment"># DB-API 2 创建连接的参数</span></span><br><span class="line">        <span class="comment"># 参数的初始化和校验 ...</span></span><br><span class="line">        self._args, self._kwargs = args, kwargs</span><br><span class="line">        self._creator = creator.connect</span><br><span class="line">        self._store(self._create())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_create</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""创建一个新的连接</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        con = self._creator(*self._args, **self._kwargs)</span><br><span class="line">        <span class="comment"># 一些参数初始化和校验 ...</span></span><br><span class="line">        self._setsession(con)</span><br><span class="line">        <span class="keyword">return</span> con</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_setsession</span><span class="params">(self, con=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> con <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            con = self._con</span><br><span class="line">        <span class="keyword">if</span> self._setsession_sql:</span><br><span class="line">            cursor = con.cursor()</span><br><span class="line">            <span class="keyword">for</span> sql <span class="keyword">in</span> self._setsession_sql:</span><br><span class="line">                cursor.execute(sql)</span><br><span class="line">            cursor.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_store</span><span class="params">(self, con)</span>:</span></span><br><span class="line">        <span class="string">"""将连接进行存储，并初始化参数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._con = con</span><br><span class="line">        self._transaction = <span class="keyword">False</span></span><br><span class="line">        self._closed = <span class="keyword">False</span></span><br><span class="line">        self._usage = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-连接的关闭和重置"><a href="#3-5-2-连接的关闭和重置" class="headerlink" title="3.5.2 连接的关闭和重置"></a>3.5.2 连接的关闭和重置</h4><p><code>closable</code> 参数控制了连接是否进行真正的关闭：</p>
<ul>
<li>如果需要进行关闭，直接关闭连接。</li>
<li>如果不进行关闭，连接又处于事务中，则会回滚。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SteadyDBConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""关闭连接，如果连接不可关闭，则重置连接</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._closeable:</span><br><span class="line">            self._close()</span><br><span class="line">        <span class="keyword">elif</span> self._transaction:</span><br><span class="line">            self._reset()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""进行实际连接关闭的函数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._closed:</span><br><span class="line">            self._con.close()</span><br><span class="line">            self._transaction = <span class="keyword">False</span></span><br><span class="line">            self._closed = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_reset</span><span class="params">(self, force=False)</span>:</span></span><br><span class="line">        <span class="string">"""如果存在事务或强制 reset，则回滚连接</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._closed <span class="keyword">and</span> (force <span class="keyword">or</span> self._transaction):</span><br><span class="line">            self.rollback()</span><br></pre></td></tr></table></figure>
<h4 id="3-5-3-连接-ping-检测"><a href="#3-5-3-连接-ping-检测" class="headerlink" title="3.5.3 连接 ping 检测"></a>3.5.3 连接 ping 检测</h4><p>SteadyDBConnection 进行 ping 检测要求 DB-API 2 的连接对象实现了 ping 方法，但是该方法并不属于 PEP 249 的规范，因此对于不支持 ping 方法的 DB-API 2 连接对象无法进行 ping 检测，如果要进行 ping 检测可以自行封装。</p>
<p>ping 检测会在连接异常时自动重新连接。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SteadyDBConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Ping connection."""</span></span><br><span class="line">        <span class="keyword">return</span> self._con.ping(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_ping_check</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ping=<span class="number">1</span>,             # 默认为获取连接的场景</span></span></span><br><span class="line"><span class="function"><span class="params">                    reconnect=True)</span>:</span>    <span class="comment"># 为 True 时，连接异常会重新连接</span></span><br><span class="line">        <span class="string">"""检查连接，如果连接异常则重新启动连接</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> ping &amp; self._ping:</span><br><span class="line">            alive = self._con.ping()</span><br><span class="line">            <span class="keyword">if</span> alive <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">                alive = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> alive:</span><br><span class="line">                reconnect = <span class="keyword">False</span></span><br><span class="line">            <span class="comment"># 如果需要进行重连且，数据库连接没有处于事务中，则重新连接</span></span><br><span class="line">            <span class="keyword">if</span> reconnect <span class="keyword">and</span> <span class="keyword">not</span> self._transaction:</span><br><span class="line">                con = self._create()</span><br><span class="line">                self._close()</span><br><span class="line">                <span class="comment"># 包装新的数据库连接</span></span><br><span class="line">                self._store(con)</span><br><span class="line">                alive = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span> alive</span><br></pre></td></tr></table></figure>
<h4 id="3-5-4-事务机制"><a href="#3-5-4-事务机制" class="headerlink" title="3.5.4 事务机制"></a>3.5.4 事务机制</h4><p>SteadyDBConnection 提供了对事务机制的包装，主要是用于决策在 reset，ping，close 时的具体行为：</p>
<ul>
<li>reset，如果处于事务中，则回滚事务。</li>
<li>ping，如果处于事务中，则不进行 reconnect。</li>
<li>close，如果不允许关闭连接，但由处于事务中，则进行连接的 reset （回滚）。</li>
</ul>
<p>SteadyDBConnection 的事务机制，完全依赖是否调用 <code>SteadyDBConnection.begin()</code> 方法，而不管 DB-API 2 的连接到底有没有提供事务。</p>
<p>正是因为这个原因：</p>
<ul>
<li>如果没有调用 SteadyDBConnection 的 <code>begin</code> 方法，虽然 MySQL 服务实际上用了事务机制，但是 SteadyDBConnection 当作没有开启事务进行处理。</li>
<li>如果调用了 SteadyDBConnection 的 <code>begin</code> 方法，虽然 DB-API 2 Connection 并没有实现 begin 方法，仍然被 SteadyDBConnection 认为开启了连接。</li>
</ul>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SteadyDBConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">begin</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""指示事务开始</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._transaction = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 事实上该方法并不属于 PEP 249，常见的 MySQL Connection 也并没有去实现 `begin()` 方法。</span></span><br><span class="line">            begin = self._con.begin</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            begin(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._transaction = <span class="keyword">False</span></span><br><span class="line">        self._con.commit()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rollback</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._transaction = <span class="keyword">False</span></span><br><span class="line">        self._con.rollback()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cancel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""取消事务，该方法并不属于 PEP 249 规范，对于常见的 MySQL Connection 没有实际作用。</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._transaction = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cancel = self._con.cancel</span><br><span class="line">        <span class="keyword">except</span> AttributeError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cancel()</span><br></pre></td></tr></table></figure>
<h4 id="3-5-5-游标"><a href="#3-5-5-游标" class="headerlink" title="3.5.5 游标"></a>3.5.5 游标</h4><p>SteadyDBConnectino 返回的 cursor 并不是 DB-API 2 Cursor，而是对其的封装：SteadyDBCursor。</p>
<p>SteadyDBCursor 的主要目的是封装其调用，计数是否触发 maxusage 以及网络请求异常时的故障恢复。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SteadyDBConnection</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cursor</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> SteadyDBCursor(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_cursor</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 获取 cursor 时进行 ping 检测</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._transaction:</span><br><span class="line">            self._ping_check(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用过多重置连接</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self._maxusage <span class="keyword">and</span> self._usage &gt;= self._maxusage:</span><br><span class="line">                <span class="keyword">raise</span> con._failure</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> self._con.cursor(*args, **kwargs)  <span class="comment"># try to get a cursor</span></span><br><span class="line">        <span class="keyword">except</span> con._failures <span class="keyword">as</span> error:</span><br><span class="line">            <span class="comment"># 故障处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SteadyDBCursor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, con, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">        <span class="comment"># 会触发进行获取 cursor 时的 ping 检测、故障处理以及 maxusage 处理</span></span><br><span class="line">        self._cursor = con._cursor(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""关闭游标</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._closed:</span><br><span class="line">            self._cursor.close()</span><br><span class="line">            self._closed = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.close()  <span class="comment"># make sure the cursor is closed</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_tough_method</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""Return a "tough" version of the given cursor method."""</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">tough_method</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            execute = name.startswith(<span class="string">'execute'</span>)</span><br><span class="line">            con = self._con</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> con._transaction:</span><br><span class="line">                con._ping_check(<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> con._maxusage <span class="keyword">and</span> con._usage &gt;= con._maxusage:</span><br><span class="line">                    <span class="comment"># 连接用的过多，抛出异常，并在故障处理中会重建连接并重新请求</span></span><br><span class="line">                    <span class="keyword">raise</span> con._failure</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> execute:</span><br><span class="line">                    self._setsizes()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 获得真正的 cursor 方法，并执行</span></span><br><span class="line">                method = getattr(self._cursor, name)</span><br><span class="line">                result = method(*args, **kwargs)  <span class="comment"># try to execute</span></span><br><span class="line">            <span class="keyword">except</span> con._failures <span class="keyword">as</span> error:  <span class="comment"># execution error</span></span><br><span class="line">                <span class="comment"># 故障处理</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                con._usage += <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">return</span> tough_method</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""代理 DB-API 2 Cursor</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._cursor:</span><br><span class="line">            <span class="keyword">if</span> name.startswith((<span class="string">'execute'</span>, <span class="string">'call'</span>)):</span><br><span class="line">                <span class="comment"># 如果请求的方法为 execute 和 call 开头，则返回一个对代理函数，该函数会进行 maxusage 判断和故障恢复</span></span><br><span class="line">                <span class="keyword">return</span> self._get_tough_method(name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> getattr(self._cursor, name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> InvalidCursor</span><br></pre></td></tr></table></figure>
<h4 id="3-5-6-故障恢复"><a href="#3-5-6-故障恢复" class="headerlink" title="3.5.6 故障恢复"></a>3.5.6 故障恢复</h4><p>故障恢复主要是处于以下场景：</p>
<ul>
<li>获取 connection。在 PooledDB 中获取连接，并进行连接检查时触发。</li>
<li>在提交事务、回滚事务时。操作失败会重新进行数据库连接，并仍然抛出异常。</li>
<li>获取 cursor。在 SteadyDBConnection 中获取 cursor，并进行连接检查时触发。</li>
<li>执行 cursor 的 execute 和 call 方法。<ul>
<li>首先检查连接，如果异常重启连接。</li>
<li>最后执行请求，如果异常则也会重启连接。</li>
</ul>
</li>
</ul>
<h2 id="四、MySQL-Client"><a href="#四、MySQL-Client" class="headerlink" title="四、MySQL Client"></a>四、MySQL Client</h2><p>在 Python 中，符合 PEP 249 规范的 MySQL Client 模块非常多，包括：</p>
<ul>
<li>MySQL-Python，在 Python2 中使用最为广泛的 MySQL Client 模块。提供 C 实现。</li>
<li>mysqlclient，是 MySQL-Python 模块的一个分支，性能非常高。</li>
<li>MySQL-Connector-Python，由 Orcale MySQL 小组官方维护，提供纯 Python 以及 C 扩展两种实现（默认使用 C 扩展）。</li>
<li>PyMySQL，纯 Python 实现，对 PEP 249 的实现较为完整。</li>
</ul>
<p>下面简单介绍 MySQL-Connector-Python 的相关特性。</p>
<h3 id="4-1-MySQL-连接"><a href="#4-1-MySQL-连接" class="headerlink" title="4.1 MySQL 连接"></a>4.1 MySQL 连接</h3><p>MySQL-Connector-Python 是一个线程不安全的连接，且每次发请求都会同步阻塞，等待服务器响应。</p>
<p>下面是连接发起请求的伪代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLConnection</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cmd_query</span><span class="params">(self, query)</span>:</span></span><br><span class="line">        <span class="string">"""发送 MySQL 语句，返回执行的基本信息，包括列信息，影响的行数等</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        result = self._handle_result(self._send_cmd(ServerCmd.QUERY, query))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_send_cmd</span><span class="params">(self, command, argument=None, ...)</span>:</span></span><br><span class="line">        <span class="string">"""构造数据包并发送</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构造请求</span></span><br><span class="line">        protocal_command = self._protocol.make_command(command, argument)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送请求</span></span><br><span class="line">        self._socket.send(protocal_command, ...)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 等待响应</span></span><br><span class="line">        <span class="keyword">return</span> self._socket.recv()</span><br></pre></td></tr></table></figure>
<h3 id="4-2-MySQL-游标"><a href="#4-2-MySQL-游标" class="headerlink" title="4.2 MySQL 游标"></a>4.2 MySQL 游标</h3><p>获得数据库连接池的游标：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cursor = cnx.cursor()</span><br></pre></td></tr></table></figure>
<p>游标实际上是一种对，MySQL 本身就有一个专门的 <a href="https://www.mysqltutorial.org/mysql-cursor/" target="_blank" rel="noopener">CURSOR</a> 对象，但是 MySQL-Connector-Python 对 Cursor 的实现并没有用 MySQL 本身的 CURSOR，而是直接用连接来进行的模拟。</p>
<p>下面是通过游标执行命令，以及获取响应的<code>伪代码</code>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySQLCursor</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self, operation, params=None,)</span>:</span></span><br><span class="line">        stmt = operation</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> params <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(params, dict):</span><br><span class="line">                stmt = _bytestr_format_dict(stmt, self._process_params_dict(params))</span><br><span class="line">            <span class="keyword">elif</span> isinstance(params, (list, tuple)):</span><br><span class="line">                psub = _ParamSubstitutor(self._process_params(params))</span><br><span class="line">                stmt = RE_PY_PARAM.sub(psub, stmt)</span><br><span class="line"></span><br><span class="line">        self._executed = stmt</span><br><span class="line">        <span class="comment"># _handle_result 会根据结果返回的数据构造 pep 249 规定的 description、rowcount、lastrowid 等数据</span></span><br><span class="line">        self._handle_result(self._connection.cmd_query(stmt))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fetchone</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self._have_unread_result():</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        row = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将数据从内核态转到用户态</span></span><br><span class="line">        (row, eof) = self._connection.get_row()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self._rowcount == <span class="number">-1</span>:</span><br><span class="line">            self._rowcount = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._rowcount += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> eof:</span><br><span class="line">            self._handle_eof(eof)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> row</span><br></pre></td></tr></table></figure>
<h2 id="附录、参考文献"><a href="#附录、参考文献" class="headerlink" title="附录、参考文献"></a>附录、参考文献</h2><ul>
<li><a href="https://www.python.org/dev/peps/pep-0249/" target="_blank" rel="noopener">[1] PEP 0249 (DB-API 2)</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0248/" target="_blank" rel="noopener">[2] PEP 0248 (DB-API 1)</a></li>
<li><a href="https://webwareforpython.github.io/DBUtils/UsersGuide.html" target="_blank" rel="noopener">[3] DBUtils User’s Guide</a></li>
<li><a href="https://github.com/lsj9383/how-to-use-mysql-in-python/blob/master/README.md">[4] How to Use MySQL in Python</a></li>
<li><a href="https://dev.mysql.com/doc/connector-python/en/" target="_blank" rel="noopener">[5] MySQL Connector/Python Developer Guide</a></li>
<li><a href="https://wiki.openstack.org/wiki/PyMySQL_evaluation" target="_blank" rel="noopener">[6] PyMySQL Evaluation</a></li>
<li><a href="https://charlesnagy.info/it/python/python-mysqldb-vs-mysql-connector-query-performance" target="_blank" rel="noopener">[7] Python MySQLdb vs mysql-connector query performance</a></li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Arthur Lu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://github.com/lsj9383/2019/01/02/DBUtils-In-Python/">http://github.com/lsj9383/2019/01/02/DBUtils-In-Python/</a></span>
                    </p>
                
                <!-- 
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                 -->
                <!-- 
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</span>
                     </p>
                 -->

            </section>
        
        <!-- <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section> -->
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2019/02/06/Flask-Context/">Flask Context</a>
            
            
            <a class="next" rel="next" href="/2018/12/10/Git-Story/">Git Story</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Arthur Lu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a></span>
    </div>
</footer>

    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
