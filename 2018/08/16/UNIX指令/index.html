<!DOCTYPE html>
<html lang="en">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="description" content="其实不过是杂记">



<title>UNIX指令 | 小记</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    



    
    
        
    


</head>
<body class="dark-theme">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">小记</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input hidden id="switch_default" type="checkbox" class="switch_default">
                <label hidden for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">小记</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">UNIX指令</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Arthur Lu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">August 16, 2018&nbsp;&nbsp;22:21:29</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>用于记录和总结UNIX系统常用指令，对于一些不常用的使用不会给出，不定期更新。</p>
<!-- TOC -->
<ul>
<li><a href="#零简单工具">零、简单工具</a><ul>
<li><a href="#1findlocate">1.<em>find/locate</em></a></li>
<li><a href="#2whichwhereis">2.<em>which/whereis</em></a></li>
<li><a href="#3chownchgrpchmod">3.<em>chown/chgrp/chmod</em></a></li>
<li><a href="#4useradduserdelpasswdsu">4.<em>useradd/userdel/passwd/su</em></a></li>
<li><a href="#6groupsusermod">6.<em>groups/usermod</em></a></li>
<li><a href="#5grep">5.<em>grep</em></a></li>
<li><a href="#6xargs">6.<em>xargs</em></a></li>
<li><a href="#7wc">7.<em>wc</em></a></li>
</ul>
</li>
<li><a href="#一系统工具">一、系统工具</a><ul>
<li><a href="#1df">1.<em>df</em></a></li>
<li><a href="#2du">2.<em>du</em></a></li>
<li><a href="#3pspstree">3.<em>ps/pstree</em></a></li>
<li><a href="#4lsof">4.<em>lsof</em></a></li>
<li><a href="#4free">4.<em>free</em></a></li>
<li><a href="#5sort">5.<em>sort</em></a></li>
</ul>
</li>
<li><a href="#三性能分析工具">三、性能分析工具</a><ul>
<li><a href="#1ab">1.<em>ab</em></a></li>
<li><a href="#2uptime">2.<em>uptime</em></a></li>
<li><a href="#3tophtop">3.<em>top/htop</em></a></li>
<li><a href="#4sar">4.<em>sar</em></a></li>
<li><a href="#5vmstat">5.<em>vmstat</em></a></li>
<li><a href="#6iostat">6.<em>iostat</em></a></li>
<li><a href="#7ifstat">7.<em>ifstat</em></a></li>
</ul>
</li>
<li><a href="#四网络工具">四、网络工具</a><ul>
<li><a href="#1curl">1.<em>curl</em></a></li>
<li><a href="#2netstat">2.<em>netstat</em></a></li>
<li><a href="#3tcpdump">3.<em>tcpdump</em></a></li>
<li><a href="#4ssh">4.<em>ssh</em></a><ul>
<li><a href="#1口令登陆">1).口令登陆</a></li>
<li><a href="#2公钥登陆">2).公钥登陆</a></li>
<li><a href="#3传输">3）.<em>传输</em></a></li>
</ul>
</li>
<li><a href="#5scp">5.<em>scp</em></a></li>
<li><a href="#6traceroute">6.<em>traceroute</em></a></li>
</ul>
</li>
<li><a href="#五程序工具">五、程序工具</a><ul>
<li><a href="#1pstack">1.<em>pstack</em></a></li>
<li><a href="#2strace">2.<em>strace</em></a></li>
</ul>
</li>
<li><a href="#六awk">六、AWK</a></li>
<li><a href="#1脚本">1.脚本</a><ul>
<li><a href="#1语句块">1).<em>语句块</em></a></li>
<li><a href="#2控制语句">2).<em>控制语句</em></a><ul>
<li><a href="#a-if条件语句">a) if条件语句</a></li>
<li><a href="#b-for循环">b) for循环</a></li>
<li><a href="#c-while循环">c) while循环</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2变量">2.变量</a><ul>
<li><a href="#1内置变量">1).内置变量</a></li>
<li><a href="#2自定义变量">2).自定义变量</a></li>
<li><a href="#3数组">3).数组</a></li>
</ul>
</li>
<li><a href="#3函数">3.函数</a><ul>
<li><a href="#1内置函数">1).<em>内置函数</em></a></li>
<li><a href="#2自定义函数">2).<em>自定义函数</em></a></li>
</ul>
</li>
<li><a href="#使用实例">使用实例</a></li>
<li><a href="#七其他">七、其他</a><ul>
<li><a href="#1procpid">1.<em>/proc/pid</em></a></li>
<li><a href="#2-devnull-21">2.<em>&gt; /dev/null 2&gt;&amp;1</em></a></li>
<li><a href="#3----">3.<code>| &gt; ; &amp;&amp; ||</code></a></li>
<li><a href="#4预启动脚本">4.<em>预启动脚本</em></a></li>
<li><a href="#5定时器任务">5.<em>定时器任务</em></a></li>
</ul>
</li>
<li><a href="#八附录">八、附录</a><ul>
<li><a href="#1icmpinternal-control-message-protocol">1.ICMP(Internal Control Message Protocol)</a></li>
</ul>
</li>
<li><a href="#九附录-参考文献">九、附录 参考文献</a></li>
</ul>
<!-- /TOC -->
<h2 id="零、简单工具"><a href="#零、简单工具" class="headerlink" title="零、简单工具"></a>零、简单工具</h2><h3 id="1-find-locate"><a href="#1-find-locate" class="headerlink" title="1.find/locate"></a>1.<em>find/locate</em></h3><p><code>find &lt;base-dir&gt; &lt;option&gt; &lt;name&gt; &lt;action&gt;</code>，对于<code>&lt;option&gt;</code>:</p>
<ul>
<li>不加<code>&lt;option&gt;</code>默认搜索当前目录及其子目录中路径中<code>包含</code>了<code>&lt;name&gt;</code>的文件和目录</li>
<li><code>- name</code>，搜索当前目录和子目录中名称等于<code>&lt;name&gt;</code>的文件和目录, 可以采用模糊搜索。</li>
<li><code>- type</code>，指定搜索的类型.f:普通文件，d:目录, p:管道文件, l:符号链接文件<br><code>&lt;action&gt;</code>指的是查询完文件后进行的操作。</li>
</ul>
<p>find运行时会对指定目录进行遍历，速度较慢。<code>locate</code>在语义上等价于<code>find -name</code>，但是他会在系统建立的数据库(/var/lib/locatedb)中进行搜索，速度非常快。系统会自动创建数据库，并且每天更新一次，因此一些新的文件或目录无法查询。<code>updatedb</code>可以手动刷新数据库。</p>
<h3 id="2-which-whereis"><a href="#2-which-whereis" class="headerlink" title="2.which/whereis"></a>2.<em>which/whereis</em></h3><ul>
<li><code>which &lt;cmd&gt;</code>，在<code>$PATH</code>中搜索指定命令的路径，一旦搜索到立即返回，后面可能会有同名的命令也无法得到执行，因为执行命令本身也是采用先搜索到的那个二进制文件。</li>
<li><code>whereis &lt;cmd&gt;</code>，在系统库中搜索指定命令的二进制文件，可能和which的结果不同。<h3 id="3-chown-chgrp-chmod"><a href="#3-chown-chgrp-chmod" class="headerlink" title="3.chown/chgrp/chmod"></a>3.<em>chown/chgrp/chmod</em></h3>这三个命令用于文件和目录的权限配置：</li>
<li><code>chown [-R] user[:grp] &lt;file&gt;</code>，将file的所属用户和所属组切换为指定的用户和组，<code>-R</code>用于递归子目录和文件。</li>
<li><code>chgrp [-R] grp &lt;file&gt;</code>，将file的所属组切换。</li>
<li><code>chmod [-R] &lt;power&gt; &lt;file&gt;</code></li>
</ul>
<h3 id="4-useradd-userdel-passwd-su"><a href="#4-useradd-userdel-passwd-su" class="headerlink" title="4.useradd/userdel/passwd/su"></a>4.<em>useradd/userdel/passwd/su</em></h3><ul>
<li>useradd, 可以添加用户<code>useradd [-m] &lt;username&gt; [-d &lt;home&gt;] [-g &lt;群组&gt;]</code>。用<code>-m</code>可以表示创建用户的时候自动生成对应的home。</li>
<li>userdel, 可以删除用户<code>userdel [-r] &lt;username&gt;</code>。通过<code>-r</code>表示删除home目录及其所有子文件。</li>
<li>passwd, 可以管理用户的密码<code>passwd [-d] [-S] &lt;username&gt;</code>。不带参数代表设置指定用户的密码，<code>-d</code>表示删除用户密码，<code>-S</code>表示显示用户密码。</li>
<li>su, 可以用于切换用户，有两种切换方式，具体如下：<ul>
<li><code>su &lt;username&gt;</code>，只切换用户，不切换环境变量，home等，目的是暂时获取某个用户的权限。</li>
<li><code>su - &lt;username&gt;</code>，切换整个坏境，包括home，环境变量。</li>
</ul>
</li>
<li><code>/etc/passwd</code>, 该文件下包含了系统的所用用户的信息。</li>
</ul>
<h3 id="6-groups-usermod"><a href="#6-groups-usermod" class="headerlink" title="6.groups/usermod"></a>6.<em>groups/usermod</em></h3><ul>
<li>groups, 可以查看当前用户的组。</li>
<li>usermod, 可以用来添加新组。</li>
<li><code>/etc/group</code>, 该文件下包含了系统的所用用户组的信息。</li>
</ul>
<h3 id="5-grep"><a href="#5-grep" class="headerlink" title="5.grep"></a>5.<em>grep</em></h3><p>经常用于重定向中，在前者的标准输出中搜索出指定的行。也可以单独用:<code>grep &lt;option&gt; &lt;file&gt; &lt;line&gt;</code>，对于<code>&lt;option&gt;</code>：</p>
<ul>
<li>-l 忽略小写</li>
<li>-c 打印匹配的行数</li>
<li>-v 打印不包含该内容的匹配行</li>
</ul>
<p><code>./a.out | grep aaa | grep -v bbb</code>,可以打印输出中包含aaa但是不包含bbb的行。</p>
<h3 id="6-xargs"><a href="#6-xargs" class="headerlink" title="6.xargs"></a>6.<em>xargs</em></h3><p>将输入到xargs命令的数据进行分割后重新排列进行输出。其默认分隔符数<code>空格和回车</code>。</p>
<ul>
<li><code>./a.out | xargs -n&lt;items&gt;</code>，将指定的输入字符串进行分割，空格和回车为分割符。将分割后的数据以一行<code>&lt;items&gt;</code>个进行输出。</li>
<li><code>./a.out | xargs</code>, 将数据全部一行输出。</li>
<li><code>./a.out | xargs -d&lt;split-char&gt; -n&lt;items&gt;</code>，设置分割符</li>
<li><code>./a.out | xargs &lt;用于输出的相关参数&gt; -p &lt;command&gt;</code>, 在组织好输出以后执行指定命令，若输出有多行，每行执行该命令。</li>
</ul>
<h3 id="7-wc"><a href="#7-wc" class="headerlink" title="7.wc"></a>7.<em>wc</em></h3><p>统计输入的简单信息:</p>
<ul>
<li><code>wc -c &lt;file&gt;</code>, 统计字节数</li>
<li><code>wc -w &lt;file&gt;</code>, 统计字数, 字指的是:由空白、跳格或换行字符分隔的字符串</li>
<li><code>wc -l &lt;file&gt;</code>, 统计行数</li>
<li><code>wc -m &lt;file&gt;</code>, 统计字符数(可显示的字符), 不可以和-c连用</li>
<li><code>wc -L &lt;file&gt;</code>, 统计最长行的长度</li>
<li><code>wc &lt;file&gt;</code>, 统计并按行数、字数，以及字节数顺序显示。</li>
</ul>
<p>wc作用的文件不但可以指定一个，还可以指定多个。除了指定文件，还可以通过<code>&lt;command&gt;|wc &lt;options&gt;</code>的方式统计输入的信息。</p>
<h2 id="一、系统工具"><a href="#一、系统工具" class="headerlink" title="一、系统工具"></a>一、系统工具</h2><h3 id="1-df"><a href="#1-df" class="headerlink" title="1.df"></a>1.<em>df</em></h3><p>查看磁盘设备的使用情况以及其挂载情况。通常搭配-h使用，用于显示合适的单位。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; df -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令输出</span></span><br><span class="line">Filesystem      Size   Used  Avail Capacity iused               ifree %iused  Mounted on</span><br><span class="line">/dev/disk1s1   233Gi   46Gi  186Gi    20% 1259054 9223372036853516753    0%   /</span><br><span class="line">devfs          184Ki  184Ki    0Bi   100%     638                   0  100%   /dev</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<h3 id="2-du"><a href="#2-du" class="headerlink" title="2.du"></a>2.<em>du</em></h3><p>对文件和目录所占用磁盘的查询。<code>du &lt;option&gt; &lt;file-or-dir&gt;</code>，常用的<code>&lt;option&gt;</code>:</p>
<ul>
<li>-s 仅显示指定目录或文件的大小</li>
<li>-c 显示所有<code>子目录</code>的大小，以及指定目录的大小</li>
<li>-a 显示指定目录中所有<code>文件</code>的大小</li>
<li>-h 显示单位</li>
</ul>
<h3 id="3-ps-pstree"><a href="#3-ps-pstree" class="headerlink" title="3.ps/pstree"></a>3.<em>ps/pstree</em></h3><p><code>ps &lt;option&gt;</code>显示进程情况，其中<code>&lt;option&gt;</code>常用的如下几项：</p>
<ul>
<li>-a/a 显示现行终端机下的所有程序，包括其他用户的程序</li>
<li>u 以用户为主的形式显示程序状况</li>
<li>-x/x 显示所有程序，不以终端机作为区分(也就是会显示守护进程)</li>
</ul>
<p>通常就用<code>ps aux</code>查询进程。</p>
<p><code>pstree &lt;option&gt; [pid|uid]</code>，这个命令可以根据进程的父子关系，以树状结构进行显示：</p>
<ul>
<li>当指定了uid，查询该用户下面的进程树</li>
<li>当指定了pid，查询该进程的进程树</li>
<li>-a 显示进程树中进程的完整参数，通常要带上</li>
</ul>
<h3 id="4-lsof"><a href="#4-lsof" class="headerlink" title="4.lsof"></a>4.<em>lsof</em></h3><p>可以查询进程与文件描述符间的情况。<code>lsof &lt;option&gt;</code>:</p>
<ul>
<li><code>lsof -i:&lt;port&gt;</code>, 查看占用指定端口的进程情况</li>
<li><code>lsof -p &lt;pid&gt;</code>, 查看指定pid进程的情况</li>
<li><code>lsof &lt;file&gt;</code>, 查看打开指定文件的进程的情况</li>
<li><code>ls -a/-o ...</code>, 可以列出多个查询要求，-a显示都符合的进程, -o显示任意符合其中一个的进程</li>
</ul>
<p>上述的情况有以下几列：</p>
<ul>
<li>COMMAND, 进程名</li>
<li>PID, 进程ID</li>
<li>USER, 所属用户</li>
<li>FD, 打开的文件描述符</li>
</ul>
<h3 id="4-free"><a href="#4-free" class="headerlink" title="4.free"></a>4.<em>free</em></h3><p>free用于查询系统的内存使用情况：<code>free &lt;option&gt;</code>，常用的<code>&lt;option&gt;</code>:</p>
<ul>
<li>-h 以便于人类阅读的形式显示</li>
<li>-k 以KB为单位显示</li>
<li>-M 以MB为单位显示</li>
<li><p><code>-s&lt;间隔秒&gt;</code> 以间隔时间进行刷新显示</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ free -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令输出</span></span><br><span class="line">             total       used       free     shared    buffers     cached</span><br><span class="line">Mem:          2016       1973         42          0        163       1497</span><br><span class="line">-/+ buffers/cache:        312       1703</span><br><span class="line">Swap:         4094          0       4094</span><br></pre></td></tr></table></figure>
</li>
<li><p>Mem 内存总览</p>
<ul>
<li>total，系统内存总量 = used + free</li>
<li>used, 系统被使用的内存，这个内存包含了进程使用的实际内存 以及 用于作为读写缓存的内存(buffer+cache)。</li>
<li>free，系统空闲内存。</li>
<li>share，基本已经废弃不用。</li>
<li>buffer，读缓冲，内存不够时，可以及时释放用于进程的内存使用。</li>
<li>cache，写缓冲，内存不够时，可以及时释放用于进程的内存使用。</li>
</ul>
</li>
<li>-/+ buffers/cache<ul>
<li>used, 指的是实际被使用的内存 = used - buffers - cache</li>
<li>free, 指的是共有多少内存可用 = free + buffers + cache</li>
</ul>
</li>
<li>swap 交换分区</li>
</ul>
<p>注：在有些系统里面显示的used时没有包含buffer和cache的。</p>
<h3 id="5-sort"><a href="#5-sort" class="headerlink" title="5.sort"></a>5.<em>sort</em></h3><p>sort是linux提供的文本行排序工具 : <code>sort [options] file</code>, 常用参数:</p>
<ul>
<li>-u, 去除重复行</li>
<li>-c, 检查文件是否已经按照顺序排序, 若是已经按顺序排列，不会输出信息。</li>
<li>-n, 依照数值的大小排序。</li>
<li>-r, 以相反的顺序来排序。</li>
<li>-o, 排序结果保存到指定的文件, 可以指定输入的文件。</li>
<li>-t, 将行分割为多个字段的分割字符, 需要和-k配合使用, 默认为空格。</li>
<li>-k, 分割后，进行排序的字段. 例如<code>sort -t &#39;:&#39; -k 3 &lt;file&gt;</code>, 指每行通过:进行分割后，第三个部分用于进行排序。</li>
</ul>
<h2 id="三、性能分析工具"><a href="#三、性能分析工具" class="headerlink" title="三、性能分析工具"></a>三、性能分析工具</h2><h3 id="1-ab"><a href="#1-ab" class="headerlink" title="1.ab"></a>1.<em>ab</em></h3><p>ab是由apache提供的一种Linux命令行压测工具，通常需要进行安装 : <code>yum -y install httpd-tools</code>, 常用的参数:</p>
<ul>
<li>-n, </li>
<li>-c, 一次产生的请求个数。默认只有一个。</li>
<li>-p, POST传输时的body文件。(ab测试不能直接在命令行中写body, 只能把body写在文件中，然后通过-p制定body文件)</li>
<li>-T, POST数据所使用的Content-type头信息。</li>
<li>-C, 附加cookie，设置key=value。多个cookie的kv对需要重复设置。</li>
<li>-k, 启用HTTP KeepAlive功能，默认不启用。</li>
<li>-i, 执行HEAD请求，而不是GET。</li>
<li>-H, 对请求附加额外的头信息。</li>
</ul>
<p>使用范例:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get请求</span></span><br><span class="line">$ ab -c 100 -n 1000 http://abc.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># post请求，并且设置content-type</span></span><br><span class="line">$ ab -c 100 -n 1000 -T <span class="string">"application/json"</span> -P &lt;post-body-file&gt; http://abc.com</span><br></pre></td></tr></table></figure></p>
<h3 id="2-uptime"><a href="#2-uptime" class="headerlink" title="2.uptime"></a>2.<em>uptime</em></h3><p>主要用于显示负载信息，也可以查看系统运行时间，常用形式不用带参数。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; uptime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令输出</span></span><br><span class="line">00:55:32 up 7 days,  1:51,  1 user,  load average: 0.00, 0.01, 0.05</span><br></pre></td></tr></table></figure></p>
<p>主要看<code>load average</code>信息，这三个数值从左到右分别代表了系统在1分钟、5分钟、15分钟的系统平均负载。<br><br>系统平均负载指的是系统平均活跃进程数，具体的计算方式是系统会每5秒统计一次活跃进程数，然后求1分钟，5分钟和15分钟的活跃数平均值。<br></p>
<ul>
<li>含义<br><br>  系统平均负载指的平均活跃进程数，对于N核，当某个时间段的load&lt;N，意味着这段时间系统会有空闲。当某个时间段的load&gt;N，意味着这段时间内有load-N的进程无法得到处理。</li>
<li><p>活跃进程<br><br>  进程有5种状态:</p>
<ul>
<li>RUNNING ：正在运行或者在就绪队列中等待运行的进程。</li>
<li>UNINTERRUPTABLE:不可中断阻塞状态，处于这种状态的进程正在等待队列中，当资源有效时，可以由操作系统唤醒，否则一直处于等待状态，例如磁盘IO操作。</li>
<li>INTERRUPTABLE：可中断阻塞状态，处于这种状态的进程在等待队列中，当资源有效时，可以由操作系统进行唤醒，处于此状态中的进程也可以被其他进程所唤醒，例如键盘输入，sleep等。</li>
<li>STOPPED：挂起状态，需要通过其它进程的信号才能被唤醒。阻塞是被动行为(等待资源就绪)，挂起是主动行为。</li>
<li><p>ZOMBIE：僵尸状态。表示进程结束但尚未消亡的一种状态，此时进程已经结束运行并释放掉大部分资源，但尚未释放进程控制块。</p>
<p>活跃进程主要指的是<code>RUNNING</code>和<code>UNINTERRUPTABLE</code>状态的进程。</p>
</li>
</ul>
</li>
<li>两种负载<br><br>  系统平均负载可以视为由两种负载组成：<code>CPU负载</code>和<code>IO负载</code>。CPU负载高的进程是CPU密集型，主要体现在CPU进行复杂的运输。IO负载高的进程是IO密集型，主要体现在大量的IO操作。其中一种密集型操作都有可能导致高负载，CPU密集型会导致大量的进程等待CPU空闲，IO密集型会导致大量的时间进行等待操作完成。IO密集型的有个特点是大量的等待时间导致高负载，并且CPU利用率较低。</li>
</ul>
<h3 id="3-top-htop"><a href="#3-top-htop" class="headerlink" title="3.top/htop"></a>3.<em>top/htop</em></h3><p>top和htop，都是linux下面的任务管理器，会显示所有进程的详细情况。htop是更加好看的显示方式。包括系统的负载、CPU使用率、任务数，进程列表。对于进程列表，通过<code>M</code>和<code>P</code>可以切换到以内存从高到低的排序以及CPU从高到低的排序。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; top</span><br><span class="line"><span class="comment"># 指令输出</span></span><br><span class="line"></span><br><span class="line">top - 01:24:44 up 12 days,  2:20,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  74 total,   2 running,  72 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1016288 total,   123064 free,   141524 used,   751700 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   704920 avail Mem</span><br><span class="line"></span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND</span><br><span class="line">334 root      20   0   94180  38168  37852 S  0.0  3.8   3:01.91 systemd-journal</span><br><span class="line">3777 root      20   0  378936  24400   5116 S  0.0  2.4  15:44.37 python3</span><br><span class="line">473 root      20   0  494808  23292  21732 S  0.0  2.3   1:43.15 rsyslogd</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一行，时间和系统负载(1min, 5min, 15min)</li>
<li>第二行，总进程数，RUNNING状态的进程数，休眠进程数，停止进程数，僵死进程数。(负载数RUNNING的进程数+休眠进程中的不可中断进程部分)</li>
</ul>
<h3 id="4-sar"><a href="#4-sar" class="headerlink" title="4.sar"></a>4.<em>sar</em></h3><p>sar, System Activity Reporter(系统活动情况报告)，可以周期性的报告性能数据。<br>总结来说:</p>
<ul>
<li>怀疑CPU存在瓶颈, <code>sar -u(报告CPU利用率)</code> 和 <code>sar -q(报告运行队列和交换队列的瓶颈长度)</code> 可以进行查看。时间利用率通常不包含io等待时间，但是负载里面考了了io等待。</li>
<li>怀疑内存存在瓶颈, <code>sar -B(查询附加的缓存使用情况)</code>, <code>sar -r(类似free，查看物理内存使用情况)</code> 和 <code>sar -W(查看交换页情况)</code> 可以进行查看。</li>
<li>怀疑IO存在瓶颈, <code>sar -b</code>, <code>sar -u(CPU利用率)</code> 和 <code>sar -d(报告磁盘使用情况)</code> 可以进行查看。</li>
</ul>
<h3 id="5-vmstat"><a href="#5-vmstat" class="headerlink" title="5.vmstat"></a>5.<em>vmstat</em></h3><p>vmstat可以观察到当前时刻的进程队列、内存、swap、磁盘io、系统终端和上下文切换、CPU时间占比等信息<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat [-a] [seconds]</span><br></pre></td></tr></table></figure></p>
<p>-a表示是否显示活跃内存大小和非活跃内存大小。参数seconds，表示多久采集一次进行显示。</p>
<ul>
<li>Process<ul>
<li>r: 进程就绪 等待执行的数量</li>
<li>b: 等待IO的进程数</li>
</ul>
</li>
<li>Memory<ul>
<li>swapd: 已使用的swap空间大小</li>
<li>free: 空闲内存大小</li>
<li>buff: 已用的buff大小，对块设备的读写进行缓冲(free不够的时候，buff会部分被释放给free使用)</li>
<li>cache: 已用的cache大小，文件系统的cache(free不够的时候，cache会部分释放给free使用)</li>
<li>inact: 非活跃内存大小，即被标明可回收的内存</li>
<li>active: 活跃的内存大小</li>
</ul>
</li>
<li>Swap<ul>
<li>si: 每秒从交换区写入内存的大小(Kb/s)</li>
<li>so: 每秒从内存写到交换区的大小(Kb/s)</li>
</ul>
</li>
<li>IO<ul>
<li>bi: 每秒读取的块数（读磁盘）</li>
<li>bo: 每秒写入的块数（写磁盘），不同的电脑上块大小可能设置的不一样，通常为4096字节或1024字节。</li>
</ul>
</li>
<li>System, 这两个值越大，会看到由内核消耗的cpu时间会越多<ul>
<li>in: 每秒中断数，包括时钟中断</li>
<li>cs: 每秒上下文切换数，调用系统函数，就要进行上下文切换。</li>
</ul>
</li>
<li>CPU<ul>
<li>us: 用户态执行消耗cpu时间</li>
<li>sy: 内核态执行消耗的cpu时间</li>
<li>id: 空闲时间(包括IO等待时间)</li>
<li>wa: 等待IO时间, sa过高时，说明io等待比较严重，这可能是由于磁盘大量随机访问造成的，也有可能是磁盘的带宽出现瓶颈。</li>
</ul>
</li>
</ul>
<h3 id="6-iostat"><a href="#6-iostat" class="headerlink" title="6.iostat"></a>6.<em>iostat</em></h3><p>iostat可以观察当前时刻磁盘io读写速度和cpu时间占比相关信息.</p>
<p>输出说明:</p>
<ul>
<li>CPU信息<ul>
<li>%user：CPU处在用户模式下的时间百分比。</li>
<li>%nice：CPU处在带NICE值的用户模式下的时间百分比。</li>
<li>%system：CPU处在系统模式下的时间百分比。</li>
<li>%iowait：CPU等待输入输出完成时间的百分比。</li>
<li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li>
<li>%idle：CPU空闲时间百分比。</li>
</ul>
</li>
<li>磁盘信息:<ul>
<li>tps：该设备每秒的传输次数</li>
<li>kB_read/s：每秒从设备（drive expressed）读取的数据量；</li>
<li>kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</li>
<li>kB_read：  读取的总数据量；</li>
<li>kB_wrtn：写入的总数量数据量；</li>
</ul>
</li>
</ul>
<h3 id="7-ifstat"><a href="#7-ifstat" class="headerlink" title="7.ifstat"></a>7.<em>ifstat</em></h3><p>可以简单的监测系统流量情况。</p>
<h2 id="四、网络工具"><a href="#四、网络工具" class="headerlink" title="四、网络工具"></a>四、网络工具</h2><h3 id="1-curl"><a href="#1-curl" class="headerlink" title="1.curl"></a>1.<em>curl</em></h3><p>curl用以模拟http请求，可以用来测试和制作爬虫。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl &lt;options&gt; <span class="string">"&lt;url&gt;"</span></span><br></pre></td></tr></table></figure></p>
<p><code>options</code>在下面列出常用的选项:</p>
<ul>
<li>-d 设置请求body，并将请求设置为POST请求</li>
<li>-H 设置请求头，每个请求头都要加一个-H。</li>
<li>-b 设置Cookie内容, 如:curl -b “a=1;b=2;c=3;”</li>
<li>-s 静默模式, 不显示错误信息和请求进度条，这在脚本中常用。</li>
<li>-S 不显示请求进度条，但是显示错误信息。</li>
<li>-i 输出http响应行(报文协议+响应状态)和响应头</li>
<li>-v 输出http请求行(method+url+报文协议)和请求头 + 响应行和响应头</li>
<li>–resolve, 提供域名解析, 个别网站(尤其是https站点)针对ip访问的请求进行拒绝, 通过该参数可以绕过。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H <span class="string">"Content-Type:application/json"</span> -d <span class="string">'&#123;"name":"lsj"&#125;'</span> <span class="string">"http://www.baidu.com"</span></span><br><span class="line"></span><br><span class="line">$ curl -s <span class="string">"http://www.baidu.com"</span></span><br><span class="line"></span><br><span class="line">$ curl -s <span class="string">"https://labs.topbook.cc/webapi/user/"</span> --resolve labs.topbook.cc:443:127.0.0.1</span><br></pre></td></tr></table></figure>
<h3 id="2-netstat"><a href="#2-netstat" class="headerlink" title="2.netstat"></a>2.<em>netstat</em></h3><p>用于查看网络状态, <code>netstat &lt;option&gt;</code>, 其中<code>&lt;option&gt;</code>选项如下所示:</p>
<ul>
<li>-a/-all 显示所有的socket</li>
<li>-n 直接显示ip地址，而非域名</li>
<li>-t 显示tcp的连接情况</li>
<li>-u 显示udp的连接情况</li>
<li>-p 显示使用socket的进程pid和进程名称</li>
</ul>
<p>最常使用的命令格式就是<code>netstat -antp</code>，即以ip形式显示所有的tcp连接，及其计算机使用该连接的进程pid和名称。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; netstat -antp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令输出</span></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:139             0.0.0.0:*               LISTEN      8010/smbd</span><br><span class="line">tcp        0      0 0.0.0.0:111             0.0.0.0:*               LISTEN      1/systemd</span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      10184/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      947/sshd</span><br><span class="line">tcp        0      0 0.0.0.0:445             0.0.0.0:*               LISTEN      8010/smbd</span><br><span class="line">tcp        0      0 127.0.0.1:5000          0.0.0.0:*               LISTEN      3770/python3</span><br><span class="line">tcp        0     36 172.27.0.5:22           220.152.162.188:49324   ESTABLISHED 4355/sshd: root@pts</span><br><span class="line">tcp        0      0 172.27.0.5:22           180.101.88.221:32567    ESTABLISHED 8764/sshd: root [pr</span><br></pre></td></tr></table></figure>
<ul>
<li>Active Internet connections，表示下面显示活跃的网络的连接</li>
<li>Proto，代表连接形式，包括<code>tcp/udp/raw</code></li>
<li>Recv-Q, 接收队列</li>
<li>Send-Q, 发送队列</li>
<li>Local Address, 表示socket的被连接/监听的一端，也就是本地的socket的ip和port</li>
<li>Foreign Address, 表示发起连接的socket的ip和port</li>
<li>State, 网络连接状态， 通常只有tcp才有连接信息</li>
<li>PID/Programe name, 故名思议</li>
<li>Active UNIX domain sockets, 表示下面Unix socket，这些socket仅用于本地通信，不是网络连接，在上图中没有列出改内容。</li>
</ul>
<h3 id="3-tcpdump"><a href="#3-tcpdump" class="headerlink" title="3.tcpdump"></a>3.<em>tcpdump</em></h3><p>tcpdump用于监听网络数据，并进行筛选。</p>
<ul>
<li>tcpdump <code>[options]</code> <code>[not]</code> <code>[proto]</code> <code>[dir]</code> <code>[ID]</code><ul>
<li>options:<ul>
<li>-c: 指定要抓取的包数量。注意, 是最终要获取这么多个包。s</li>
<li>-i interface: 指定tcpdump需要监听的接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback接口, 要抓取loopback接口使用<code>tcpdump -i lo</code>)。</li>
<li>-n: 对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。</li>
<li>-nn: 除了-n的作用外，还把端口显示为数值，否则显示端口服务名。</li>
<li>-q: 快速打印输出.即打印很少的协议相关信息, 从而输出行都比较简短。</li>
<li>-v: 当分析和打印的时候, 产生详细的输出。</li>
<li>-vv: 产生比-v更详细的输出。</li>
<li>-vvv: 产生比-vv更详细的输出。</li>
<li>-w: 将抓包数据输出到文件中而不是标准输出。可通过”-r”选项载入这些文件以进行分析和打印。</li>
<li>-r: 从给定的数据包文件中读取数据。使用”-“表示从标准输入中读取。</li>
</ul>
</li>
<li>not, 对后面的过滤条件进行取反</li>
<li>proto, 限定匹配的数据包协议<ul>
<li>tcp</li>
<li>udp</li>
<li>arp</li>
<li>ip</li>
<li>ether</li>
<li>icmp</li>
</ul>
</li>
<li>dir, 限定相对于ID的方向<ul>
<li>dst, 数据包的发送目标是ID</li>
<li>src, 数据包的来源是ID</li>
</ul>
</li>
<li>ID, 指定ID，默认是host, 可以进行组合<ul>
<li>host <code>&lt;host-name&gt;</code>, 抓IP地址为host的包</li>
<li>net <code>&lt;net&gt;</code>, 抓指定网段的包</li>
<li>port <code>&lt;port-number&gt;</code>, 抓指定端口的包</li>
</ul>
</li>
<li>tcpdump <code>[options]</code>后面的部分，可以通过<code>and/&amp;&amp;</code>, <code>or/||</code>和<code>not/!</code>以及括号进行组合。</li>
</ul>
</li>
</ul>
<p>常用命令:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出可以进行抓包的网卡</span></span><br><span class="line">tcpdump -D</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取指定网卡的数据</span></span><br><span class="line">tcpdump -i &lt;interface&gt;</span><br><span class="line">tcpdump -v -i &lt;interface&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓取指定端口的包</span></span><br><span class="line">tcpdump -i &lt;interface&gt; port &lt;port-number&gt;   <span class="comment"># 该端口流入流出的包都抓</span></span><br><span class="line">tcpdump -i &lt;interface&gt; src &lt;port-number&gt;    <span class="comment"># 抓从该端口流出的包(该端口发送出数据)</span></span><br><span class="line">tcpdump -i &lt;interface&gt; dst &lt;port-number&gt;    <span class="comment"># 抓流入该端口的包(向该端口发送数据)</span></span><br></pre></td></tr></table></figure></p>
<p>tcpdump还有一系列的过滤表达式，可以进行组合，进而完成复杂的抓包工作。tcpdump的响应的标识含义:</p>
<ul>
<li><code>[S.]</code>, SYN，发起连接标志。</li>
<li><code>[P.]</code>, PUSH，传送数据标志。</li>
<li><code>[F.]</code>, FIN，关闭连接标志。</li>
</ul>
<h3 id="4-ssh"><a href="#4-ssh" class="headerlink" title="4.ssh"></a>4.<em>ssh</em></h3><p>ssh由两种登陆方式，这两种登陆方式都会涉及到公钥私钥，但是对公钥私钥的使用方法是完全不同的。</p>
<h4 id="1-口令登陆"><a href="#1-口令登陆" class="headerlink" title="1).口令登陆"></a>1).口令登陆</h4><p>口令登陆本质上是输入密码口令，但是为了保护密码口令在internet中的安全传输，会采用服务器的公钥对口令进行加密，服务器用对应的私钥进行解密，口令正确，则允许客户端登陆。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh [-p &lt;port&gt;] username@host</span><br></pre></td></tr></table></figure></p>
<p>首次登陆服务器，ssh将会提示是否保存由服务器分发的公钥。通常选yes，将公钥在ssh客户端上进行保存，并且通常保存在<code>~/.ssh/known_hosts</code>文件中。将服务器公钥加入文件中后，重新登陆，不会再询问。有两种密码校验错误的情况:</p>
<ul>
<li>公钥正确，私钥解密成功，密码不匹配。</li>
<li>公钥错误，导致私钥解密失败，这可能是由于服务器端用户密码修改过导致的，这需要重新获取服务器公钥，只需要删掉known_hosts中对应的公钥行即可。重新登陆便能重新获取公钥。</li>
</ul>
<h4 id="2-公钥登陆"><a href="#2-公钥登陆" class="headerlink" title="2).公钥登陆"></a>2).公钥登陆</h4><p>client生成公钥-私钥对，并将公钥分发送给server。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成公钥私钥对(~/.ssh/id_rsa.pub/和~/.ssh/id_rsa)</span></span><br><span class="line">$ ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上次生成的公钥发送给指定的服务器</span></span><br><span class="line">$ ssh-copy-id username@host</span><br></pre></td></tr></table></figure></p>
<p>远程主机将用户的公钥，保存在登录后的用户主目录的<code>$~/.ssh/authorized_keys</code>文件中。公钥登陆流程如下：</p>
<ul>
<li><code>$ ssh [-p &lt;port&gt;] username@host</code></li>
<li>server生成random并用public进行加密</li>
<li>server发送密文random给client</li>
<li>client对密文random用private进行解密</li>
<li>client将解密结果生成md5，再发送给server</li>
<li>server比对客户端的数据和md5(random)， 若相等则允许客户端登陆</li>
</ul>
<p>由始至终都没有暴露random具体数值</p>
<h4 id="3）-传输"><a href="#3）-传输" class="headerlink" title="3）.传输"></a>3）.<em>传输</em></h4><ul>
<li><code>口令登陆</code>就采用口令对数据内容进行加密解密。</li>
<li><code>公钥登陆</code>就采用服务器生成的random对内容进行加密解密。</li>
</ul>
<h3 id="5-scp"><a href="#5-scp" class="headerlink" title="5.scp"></a>5.<em>scp</em></h3><p>cp用于文件或文件夹在本地的拷贝，scp用于将本地的文件或目录拷贝到指定的远程机器。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将&lt;local-path&gt;的文件拷贝到指定计算机上，并且使用的上username的权限</span></span><br><span class="line">scp &lt;<span class="built_in">local</span>-path&gt; username@host:path</span><br><span class="line"></span><br><span class="line"><span class="comment"># -r参数用于递归拷贝子目录及其文件</span></span><br><span class="line">scp -r &lt;<span class="built_in">local</span>-path&gt; username@host:path</span><br></pre></td></tr></table></figure></p>
<h3 id="6-traceroute"><a href="#6-traceroute" class="headerlink" title="6.traceroute"></a>6.<em>traceroute</em></h3><p>traceroute命令用于打印从原地址到目的地址中间的路由器/网关的IP，在应用中出现丢包问题时可以通过该命令查看到时哪个路由器发生了丢包导致数据无法传输到目的地址。traceroute会对每个路由器探测3次，获得其响应时间。</p>
<p>Linux通常没有自带该命令，需要进行安装:<code>yum -y install traceroute</code>。命令格式:</p>
<ul>
<li><code>tracereoute &lt;options&gt; &lt;dest&gt;</code><ul>
<li>-m&lt;存活数值&gt;： 设置检测数据包的最大存活设置，即hops。当探测的ttl增大到该hops时还未达到主机，则探测结束。默认30。</li>
<li>-s&lt;来源地址&gt;：设置本地主机送出数据包的IP地址。</li>
<li>-w&lt;超时秒数&gt;：设置等待远端主机回报的时间。</li>
<li>-f&lt;存活数值&gt;：设置第一个检测数据包的存活数值TTL的大小。</li>
</ul>
</li>
</ul>
<p>traceroute是一个基于UDP和ICMP的工具(发送请求通过UDP, 响应为ICMP), 在路由器需要有一个监听traceroute的UDP包的端口，通常大于30000。traceroute的工作步骤为:</p>
<ul>
<li>a) 初始化ttl为1，向dest发起UDP包</li>
<li>b) 路由器收到ttl为1的UDP包，会立即丢弃该包，并返回TTL超时的<code>ICMP报文</code>。</li>
<li>c) src接收到TTL超时的结果，会打印响应包中的IP地址，即路由器IP。</li>
<li>d) src将ttl递增，再次向dest发起UDP包</li>
<li>e) UDP包在网络中传输，当ttl为0时返回ttl超时响应, 并回到步骤 d)</li>
<li>f) 应用服务器通常不会监听traceroute所用的端口，因此到达应用服务器后就会返回<code>端口不可达</code>的响应。</li>
<li>g) src收到<code>端口不可达</code>的响应，就认为已经到了目的主机了。</li>
</ul>
<p>需要注意，由于安全问题，所以可能拿不到<code>端口不可达</code>的<code>ICMP报文</code>, 而是直接废弃该包, 因此src会一直接收到ttl超时的响应，进而不断的增加ttl进行探测，直到打到最大的hops, 但其实已经到达过dest了。</p>
<h2 id="五、程序工具"><a href="#五、程序工具" class="headerlink" title="五、程序工具"></a>五、程序工具</h2><h3 id="1-pstack"><a href="#1-pstack" class="headerlink" title="1.pstack"></a>1.<em>pstack</em></h3><h3 id="2-strace"><a href="#2-strace" class="headerlink" title="2.strace"></a>2.<em>strace</em></h3><h2 id="六、AWK"><a href="#六、AWK" class="headerlink" title="六、AWK"></a>六、AWK</h2><p>awk是一种文本处理和分析工具，可以对指定的单个文本文件进行处理，也可以对标准输入的文本进行处理，处理单位通常为一行。awk的常用格式:</p>
<ul>
<li><code>awk [&lt;options&gt;] &#39;&lt;script&gt;&#39; &lt;file&gt;</code><ul>
<li>-F 设置分隔符，如<code>-F &quot;:&quot;</code>, <code>-F :</code> 都可以设置<code>冒号:</code>为分隔符，默认分隔符为空格和制表符。</li>
<li>-v 定义和声明程序中可以使用的变量, 多个变量可以使用多个-v设置。如<code>-v a=3 -v b=4</code>, 在脚本中a和b就代表着变量。</li>
</ul>
</li>
</ul>
<h2 id="1-脚本"><a href="#1-脚本" class="headerlink" title="1.脚本"></a>1.脚本</h2><p><code>&lt;script&gt;</code>里面可以编写命令脚本，awk会读取每一行，并对该行执行脚本程序获得的输出作为新的一行。需要注意，脚本一定是用<code>单引号</code>来进行引用。</p>
<h3 id="1-语句块"><a href="#1-语句块" class="headerlink" title="1).语句块"></a>1).<em>语句块</em></h3><p>脚本由3个代码块组成:</p>
<ul>
<li>初始化代码块, 在文件处理开始前(命令代码块运行前)进行执行, 通常是一些初始化工作。由BEGIN标示后接<code>{...}</code>, 可忽略。</li>
<li>命令代码块, 对每一行输入都执行一次该代码块，不需要标示，直接用<code>{...}</code></li>
<li>结尾代码块, 在文件处理完毕后(命令代码块执行完毕)执行的最终代码块。由END标示后接<code>{...}</code>, 可忽略。</li>
</ul>
<p>很明显，在BEGIN和END代码块中，都没有行输入，所以不存在$num。如<code>BEGIN{A=0; B=0} {print $0} END{print A,&quot;\t&quot;,B}</code>, 最简单的是只有令代码块<code>{print $0}</code>。另外 若是单纯的希望执行awk命令，不进行任何的输入处理，可以利用BEGIN语句块完成。</p>
<h3 id="2-控制语句"><a href="#2-控制语句" class="headerlink" title="2).控制语句"></a>2).<em>控制语句</em></h3><h4 id="a-if条件语句"><a href="#a-if条件语句" class="headerlink" title="a) if条件语句"></a>a) if条件语句</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法格式</span></span><br><span class="line">if (condition)</span><br><span class="line">    action</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span>(condition) action</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span>语句块</span></span><br><span class="line">if (condition) &#123;</span><br><span class="line">    action-1;</span><br><span class="line">    action-2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">if</span>-else</span></span><br><span class="line">if (condition-1)</span><br><span class="line">    action-1</span><br><span class="line">else if (condition-2)</span><br><span class="line">    action-2</span><br><span class="line">else</span><br><span class="line">    action-3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN &#123;num = 10; if (num % 2 == 0) printf "%d 是偶数\n", num &#125;'</span></span></span><br></pre></td></tr></table></figure>
<h4 id="b-for循环"><a href="#b-for循环" class="headerlink" title="b) for循环"></a>b) for循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法格式</span></span><br><span class="line">for (initialisation; condition; increment/decrement)</span><br><span class="line">    action</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 迭代器语法格式，和数组进行配合, 需要注意awk的数组是关联数组，也就是map。</span></span><br><span class="line">for (k in arrays)</span><br><span class="line">    action</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN &#123; for (i = 1; i &lt;= 5; ++i) print i &#125;'</span></span></span><br></pre></td></tr></table></figure>
<h4 id="c-while循环"><a href="#c-while循环" class="headerlink" title="c) while循环"></a>c) while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法格式</span></span><br><span class="line">while (condition)</span><br><span class="line">    action</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Demo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN &#123;i = 1; while (i &lt; 6) &#123; print i; ++i &#125; &#125;'</span></span></span><br></pre></td></tr></table></figure>
<h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><h3 id="1-内置变量"><a href="#1-内置变量" class="headerlink" title="1).内置变量"></a>1).内置变量</h3><ul>
<li>NR, 每个行在输入中的行号，多个文件作为输入时，NR是在多个文件拼接成的输入中的行号</li>
<li>FNR, 每个行在输入中的行号，多个文件作为输入时，FNR仅仅为该行在该文件中的行号</li>
<li>NF, 每行分割后的字段个数</li>
<li>$num, 表示分割后的第num个字段, $0表示该行整行, $1表示该行分割后的第一个字段, $2表示第2个字段</li>
<li>FS, 分隔符字段</li>
<li>FILENAME, 输入文件的名字</li>
</ul>
<h3 id="2-自定义变量"><a href="#2-自定义变量" class="headerlink" title="2).自定义变量"></a>2).自定义变量</h3><p>自定义变量的初始化通常在BEGIN语句块中或是awk命令中通过-v来完成。</p>
<h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3).数组"></a>3).数组</h3><p>AWK中可以使用关联数组这种数据结构，索引可以是数字或字符串。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加kv(添加时若不存在，隐含着创建)</span></span><br><span class="line">array_name[index]=value</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除kv</span></span><br><span class="line">delete array_name[index]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 循环</span></span><br><span class="line">for (index in array_name) &#123;</span><br><span class="line">    print index, "---", array_name[index]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><h3 id="1-内置函数"><a href="#1-内置函数" class="headerlink" title="1).内置函数"></a>1).<em>内置函数</em></h3><ul>
<li>print, 输出新的一行，多个字符串通过逗号拼接，如<code>print $1, &quot;----&quot;, $2</code></li>
<li>systime(), 时间戳函数</li>
</ul>
<h3 id="2-自定义函数"><a href="#2-自定义函数" class="headerlink" title="2).自定义函数"></a>2).<em>自定义函数</em></h3><p>自定义函数的语句块，通常放在BEGIN语句块、命令语句块、END语句块的外面。直接通过一个demo来演示如何创建函数:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回最小值</span></span><br><span class="line">awk '</span><br><span class="line">function find_min(num1, num2) &#123;</span><br><span class="line">  if (num1 &lt; num2)</span><br><span class="line">    return num1</span><br><span class="line">  return num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BEGIN &#123;</span><br><span class="line">    # 查找最小值</span><br><span class="line">    result = find_min(10, 20)</span><br><span class="line">    print "Minimum =", result</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure></p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印Nginx进程相关的pid</span></span><br><span class="line">$ ps aux|grep nginx:|grep -v grep|awk <span class="string">'&#123;print $2&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印pid小于80的进程</span></span><br><span class="line">$ ps aux|awk <span class="string">'$2&lt;80 &#123;print $0&#125;'</span></span><br><span class="line">$ ps aux|awk <span class="string">'&#123;if($2&lt;80) print $0&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出pid小于80进程的行号</span></span><br><span class="line">$ ps aux|awk <span class="string">'&#123;if($2&lt;80) print NR, "-----", $0&#125;'</span></span><br></pre></td></tr></table></figure>
<h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h3 id="1-proc-pid"><a href="#1-proc-pid" class="headerlink" title="1./proc/pid"></a>1.<em>/proc/pid</em></h3><p><code>/proc/&lt;pid&gt;</code>并没有保存在磁盘中，而是内存中，这个目录下是对应进程id的运行环境，包括其可执行文件的软连接。</p>
<h3 id="2-gt-dev-null-2-gt-amp-1"><a href="#2-gt-dev-null-2-gt-amp-1" class="headerlink" title="2.&gt; /dev/null 2&gt;&amp;1"></a>2.<em>&gt; /dev/null 2&gt;&amp;1</em></h3><p>这是一个非常常见的查询启动命令<code>./a.out &gt; /dev/null 2&gt;&amp;1</code>，这里的<code>/dev/null</code>是一个黑洞，向起进行的所有输出都不会被保存，而是直接扔弃。对于这条命令的解释是：程序的标准输出重定向到/dev/null，以丢弃标准输出，接着把标识错误重定向到标准输出上，因为此时标准输出对应的是/dev/null，因此标准错误输出也是定位到/dev/null。简而言之，对进程的标准错误和标准输出全部屏蔽。<br><br>也常见<code>./a.out 2&gt;&amp;1 &gt; /dev/null</code>，这代表将标准错误定向到标准输出，即显示屏，再将标准输出重定向到/dev/null，很明显，这将导致标准输出内容屏蔽，并将标准错误输出到屏幕。</p>
<h3 id="3-gt-amp-amp"><a href="#3-gt-amp-amp" class="headerlink" title="3.| &gt; ; &amp;&amp; ||"></a>3.<code>| &gt; ; &amp;&amp; ||</code></h3><ul>
<li><code>a | b</code>  用于管道重定向，将左边的标准输出和右边的标准输入连接</li>
<li><code>a &gt; b</code>  也是重定向，不过数和指定的文件或文件描述符进行连接</li>
<li><code>a ; b</code>  按顺序执行</li>
<li><code>a &amp;&amp; b</code> a成功则执行b，否则不执行b</li>
<li><code>a || b</code> a失败则执行b，否则不执行b</li>
</ul>
<h3 id="4-预启动脚本"><a href="#4-预启动脚本" class="headerlink" title="4.预启动脚本"></a>4.<em>预启动脚本</em></h3><p>当login获取一个shell时，会启动一系列预启动脚本，这些脚本里面包含了初始化配置。</p>
<ul>
<li>首先读取<code>/etc/profile</code>，这是所有用户共享的。</li>
<li>读取<code>~/.bash_profile</code>，<code>~/.bash_login</code>，<code>~/.profile</code>，这是用户特定，可以实现用户个性定制。</li>
<li>最后读取<code>~/.bashrc</code>。需要注意的是，该脚本在每个shell scripts执行前都会进行运行。</li>
</ul>
<h3 id="5-定时器任务"><a href="#5-定时器任务" class="headerlink" title="5.定时器任务"></a>5.<em>定时器任务</em></h3><p>通过<code>crontab</code>命令，可以编写定时处理的脚本，并且不同的用户的定时器任务是相互隔离的。<code>crontab &lt;option&gt;</code>，其中的<code>&lt;option&gt;</code>有如下常见项：</p>
<ul>
<li><code>-u &lt;user&gt;</code> 用作于指定用户，若没有指定，则作用于当前用户</li>
<li><code>-e</code> 编辑crontab文件(某些系统需要环境变量<code>EDITOR=vi</code>)，默认情况下crontabl将会创建至<code>/tmp</code>文件夹中，重启将会被删除。</li>
<li><code>-l</code> 显示crontab文件内容</li>
<li><code>-r</code> 删除crontab文件</li>
<li><code>crontab &lt;file&gt;</code> 直接用<code>&lt;file&gt;</code>作为crontab文件<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每次时间变化(分钟为单位)，新的时间满足下列条件时将会执行&lt;command&gt;</span></span><br><span class="line"><span class="comment"># *代表任意时间, -代表时间范围， 逗号表示时间的或关系。</span></span><br><span class="line">分 时 日 月 周 &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每分钟执行</span></span><br><span class="line">* * * * * &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天的十点执行</span></span><br><span class="line">0 10 * * * &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每小时的3分和15分执行</span></span><br><span class="line">3,15 * * * * &lt;<span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="八、附录"><a href="#八、附录" class="headerlink" title="八、附录"></a>八、附录</h2><h3 id="1-ICMP-Internal-Control-Message-Protocol"><a href="#1-ICMP-Internal-Control-Message-Protocol" class="headerlink" title="1.ICMP(Internal Control Message Protocol)"></a>1.ICMP(Internal Control Message Protocol)</h3><p>ICMP报文其实是一个IP报文，IP报文中的用户数据即ICMP报文的数据。这里略去IP报文的每个字段含义，只给出其中最重要的字段: <code>类型</code>，该字段标示了ICMP报文所反应的网络情况，包含了一下取值:</p>
<ul>
<li>类型3(目标不可达), 路由器判断出不能吧IP数据包送达目标主机, 则向源主机返回这种报文。目标主机找不到上层协议的访问点也会返回该报文。传输层的端口不可达也是返回类型3的ICMP包。</li>
<li>类型11(超时), IP数据包的TTL为0, 数据包被丢弃。</li>
<li>类型8/0(回声请求/响应), 即ping命令发出的ICMP包, 发送类型为8的ICMP请求, 若路由无异常则会接收到类型为0的ICMP响应。主要用于测试通信线路是否通常以及请求耗时。</li>
</ul>
<h2 id="九、附录-参考文献"><a href="#九、附录-参考文献" class="headerlink" title="九、附录 参考文献"></a>九、附录 参考文献</h2><ul>
<li><a href="http://man.linuxde.net/" target="_blank" rel="noopener">Linux命令大全</a></li>
<li><a href="https://www.jianshu.com/p/75a5822d0eec" target="_blank" rel="noopener">traceroute原理</a></li>
<li>网络工程师教程</li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Arthur Lu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://github.com/lsj9383/2018/08/16/UNIX指令/">http://github.com/lsj9383/2018/08/16/UNIX指令/</a></span>
                    </p>
                
                <!-- 
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                 -->
                <!-- 
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</span>
                     </p>
                 -->

            </section>
        
        <!-- <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section> -->
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/11/14/跨域问题及解决方案/">跨域问题及解决方案</a>
            
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Arthur Lu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a></span>
    </div>
</footer>

    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
