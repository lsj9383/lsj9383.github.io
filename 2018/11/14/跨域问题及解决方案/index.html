<!DOCTYPE html>
<html lang="en">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="description" content="其实不过是杂记">



<title>跨域问题及解决方案 | 小记</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
    



    
    
        
    


</head>
<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">小记</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>

        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">小记</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">跨域问题及解决方案</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">Arthur Lu</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">November 14, 2018&nbsp;&nbsp;22:55:50</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="一、跨域问题"><a href="#一、跨域问题" class="headerlink" title="一、跨域问题"></a>一、跨域问题</h1><h2 id="1-何为跨域"><a href="#1-何为跨域" class="headerlink" title="1.何为跨域"></a>1.何为跨域</h2><p>跨域请求中的域的概念由三部分组成：<code>协议</code>, <code>域名</code>和<code>端口</code>，当两个域的协议、域名和端口都相同时，即同域，否则为不同域。跨域请求是指浏览器中，域A的资源发起请求获取域B资源。</p>
<h2 id="2-浏览器对跨域的限制"><a href="#2-浏览器对跨域的限制" class="headerlink" title="2.浏览器对跨域的限制"></a>2.浏览器对跨域的限制</h2><p>出于安全原因考虑，<code>浏览器</code>对跨域请求做了一些限制: 来自域A的<code>脚本</code>发起了对域B的请求，需要进行<code>跨域校验</code>。当跨域校验成功时，脚本才能正确的获取到对应的数据，需要注意这里存在两种可能的阻止脚本请求域B数据的策略:</p>
<ul>
<li>请求没有发出，脚本无法获取数据。</li>
<li>请求已经发出，浏览器拿到响应，但是浏览器禁止脚本拿到响应数据。(主流浏览器使用该策略, 如chrome)</li>
</ul>
<p>跨域限制并不存在于http请求本身，而是浏览器的跨域校验，并且是只对脚本发起的http请求进行。对于<code>&lt;img&gt;</code>、<code>&lt;script&gt;</code>和<code>&lt;form&gt;</code>等标签而言，是允许不做任何安全校验进行跨域访问的，这也是后面<code>JSONP</code>的跨域解决方案可以得以实施的原因。跨域校验失败的时候，脚本是无法获取到失败原因的，只能打开控制台观察。下图显示了由脚本发起的GET请求的跨域校验失败:<br><img src="get-cors-failed.png" alt="GET跨域"></p>
<h1 id="二、CORS解决方案"><a href="#二、CORS解决方案" class="headerlink" title="二、CORS解决方案"></a>二、CORS解决方案</h1><p>CORS即跨域共享标准(Cross-Origin Sharing Standard)，Web浏览器通过制定一套协议来提供对CORS的支持。这个协议主要是在请求和响应中添加适当的Headers，这些特殊的Headers标明了哪种HTTP请求的响应允许脚本去获取数据。CORS有两种请求:<code>简单请求</code>和<code>预检请求</code>, 其中预检请求会先发送<code>OPTIONS</code>请求，检查服务器是否对紧接着的数据请求支持。简单请求和预检请求都是由Web浏览器自动根据实际的数据请求进行选择并发起。</p>
<h2 id="1-简单请求"><a href="#1-简单请求" class="headerlink" title="1.简单请求"></a>1.简单请求</h2><p>简单请求会直接发送HTTP请求并获得响应，浏览器根据响应的<code>CORS-HEADERS</code>，判断脚本是否有权限获取响应数据。当请求满足以下几个条件时，属于简单请求:</p>
<ul>
<li>使用下列方法之一:<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
</li>
<li>只使用了CORS安全HEADERS集合:<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type(在一些特殊的取值时为简单请求)</li>
</ul>
</li>
<li>Content-Type为下列3者之一:<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
</li>
</ul>
<p>简单请求发出后，一般而言是有响应Body的，但是浏览器是否允许脚本获取Body，就需要观察<code>HTTP-CORS响应字段</code>了。</p>
<p>通常而言，简单请求的必选的<code>HTTP-CORS响应字段</code>为<code>Access-Control-Allow-Origin</code>，若不指定则不支持任何跨域请求。若指定为<code>*</code>，则支持所有的跨域访问。</p>
<h2 id="2-非简单请求"><a href="#2-非简单请求" class="headerlink" title="2.非简单请求"></a>2.非简单请求</h2><p>对于不满足<code>简单请求</code>条件的，这里称为<code>非简单请求</code>。由于<code>简单请求</code>实际上是拿到了响应，若响应Body很大会加重网络带宽，因此在脚本发送某些请求的时候，浏览器会先发送一个<code>预检请求</code>，检查是否能够发送实际的请求，若通过检查，则发送实际的请求，否则无法发送实际的请求。预检请求是一个<code>OPTIONS</code>请求，一次非简单请求需要三步:</p>
<ul>
<li>预检请求, 脚本发送HTTP请求, 浏览器自动发送OPTIONS预检请求。</li>
<li>实际请求, 验证预检请求的<code>CORS-HEADERS</code>, 验证通过, 浏览器发送实际请求。</li>
<li>获取body, 验证响应的<code>CORS-HEADERS</code>, 验证通过, 脚本可以获取body。</li>
</ul>
<h3 id="1-非简单请求条件"><a href="#1-非简单请求条件" class="headerlink" title="1).非简单请求条件"></a>1).<em>非简单请求条件</em></h3><p>不满足<code>简单请求</code>条件的请求，都会触发预检请求，更具体的说，包含以下任一条件，都会出发预检查请求：</p>
<ul>
<li>使用了下面任一方法：<ul>
<li>PUT</li>
<li>DELETE</li>
<li>CONNECT</li>
<li>OPTIONS</li>
<li>TRACE</li>
<li>PATCH</li>
</ul>
</li>
<li>设置了CORS安全的HEADERS之外的其他HEADERS。CORS安全HEADERS为：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
</ul>
</li>
<li>Content-Type 的值不属于下列之一:<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
</ul>
<p>需要明确的是，预检请求是由浏览器自动发出的，js逻辑无需关心，并在浏览器接收到预检请求的响应后，浏览器将会判断是否允许发送实际的请求。注意，实际的请求的响应中，也需要有明确对<code>Access-Control-Allow-Origin</code>的支持。</p>
<h3 id="2-重定向问题"><a href="#2-重定向问题" class="headerlink" title="2).重定向问题"></a>2).重定向问题</h3><p>对于预检请求的重定向响应，不同的浏览器处理方式不同，但是绝大多数浏览器不支持针对于预检请求的重定向。如果一个预检请求发生了重定向，浏览器将报告错误。</p>
<h2 id="3-跨域请求HEADERS"><a href="#3-跨域请求HEADERS" class="headerlink" title="3.跨域请求HEADERS"></a>3.跨域请求HEADERS</h2><p>跨域请求的headers。这些字段无须手动设置，使用脚本发起跨域请求时，浏览器会自动设置。若对这些headers手动设置，浏览器将会拒绝，如报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Refused to set unsafe header &quot;Access-Control-Request-Method&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-Origin"><a href="#1-Origin" class="headerlink" title="1).Origin"></a>1).<em>Origin</em></h3><p>origin参数的值为源站URI中的<code>协议://域名:端口</code>，如<code>https://plat.tgp.qq.com</code>。需要注意，无论是否为跨域请求，该参数始终会被浏览器发送。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Origin: &lt;origin&gt;</span><br></pre></td></tr></table></figure></p>
<p>不支持多个Origin。</p>
<h3 id="2-Access-Control-Request-Method"><a href="#2-Access-Control-Request-Method" class="headerlink" title="2).Access-Control-Request-Method"></a>2).<em>Access-Control-Request-Method</em></h3><p>该header用于<code>预检请求</code>。其作用是在OPTIONS请求中，将实际请求的方法通过该header告诉服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Method: &lt;method&gt;</span><br></pre></td></tr></table></figure></p>
<p>实际请求的方法只可能一种，因此不支持请求多个method。</p>
<h3 id="3-Access-Control-Request-Headers"><a href="#3-Access-Control-Request-Headers" class="headerlink" title="3).Access-Control-Request-Headers"></a>3).<em>Access-Control-Request-Headers</em></h3><p>该header用于<code>预检请求</code>。其作用是在OPTIONS请求中，将实际请求方法中携带的header告诉服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></p>
<p>实际请求中携带的header可能会很多，因此支持请求多个headers，通过逗号分割。需要注意，满足下列任意条件，就是值请求方法中<code>携带</code>了headers:</p>
<ul>
<li>在请求的<code>headers</code>中添加了非CORS安全HEADER</li>
<li>Content-Type不为下列值之一:<ul>
<li>application/x-www-form-urlencoded</li>
<li>multipart/form-data</li>
<li>text/plain</li>
</ul>
</li>
</ul>
<h2 id="4-CORS-HEADERS"><a href="#4-CORS-HEADERS" class="headerlink" title="4.CORS-HEADERS"></a>4.CORS-HEADERS</h2><h3 id="1-Access-Control-Allow-Origin"><a href="#1-Access-Control-Allow-Origin" class="headerlink" title="1).Access-Control-Allow-Origin"></a>1).<em>Access-Control-Allow-Origin</em></h3><p>告知浏览器，哪些域下的资源可以获取该响应。对于不需要携带cookie的请求，服务器可以指定该字段的值为通配符，表示允许来自所有域的请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: &lt;origin&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-Access-Control-Expose-Headers"><a href="#2-Access-Control-Expose-Headers" class="headerlink" title="2).Access-Control-Expose-Headers"></a>2).<em>Access-Control-Expose-Headers</em></h3><p>脚本只能从CORS响应中拿取少数的headers，包括:</p>
<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma</li>
</ul>
<p>若脚本需要访问其他的headers，需要服务器的准许，而<code>Access-Control-Expose-Headers</code>字段就是用服务器用于声明哪些headers可以让脚本进行读取的。</p>
<h3 id="3-Access-Control-Max-Age"><a href="#3-Access-Control-Max-Age" class="headerlink" title="3).Access-Control-Max-Age"></a>3).<em>Access-Control-Max-Age</em></h3><p>脚本发一个非简单请求会首先发送预检请求，若每次请求都发送一次预检请求，则太浪费带宽。每次预检成功，结果都会缓存一段时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Max-Age: &lt;delta-seconds&gt;</span><br></pre></td></tr></table></figure></p>
<p>delta-seconds 参数表示预检请求的结果在多少秒内有效。若没有显示的设置，则浏览器自身维护了一个默认值，不同的浏览器的默认值设置或许会有不同，通常不会很长。</p>
<h3 id="4-Access-Control-Allow-Credentials"><a href="#4-Access-Control-Allow-Credentials" class="headerlink" title="4).Access-Control-Allow-Credentials"></a>4).<em>Access-Control-Allow-Credentials</em></h3><p>该header用于控制跨域请求中cookie的行为。默认情况下，cookies是不会包含在跨域请求中的，除非通过<code>Access-Control-Allow-Credentials:true</code>明确表示了服务器接收跨域请求的cookie。当设置为true时，不允许设置<code>Origin:*</code>,而是将该header设置为一个确定型的Domain，否则浏览器的该跨域请求会报错。</p>
<p>服务器放通过<code>Access-Control-Allow-Credentials:true</code>允许接收cookie后，还需要配置Ajax的<code>withCredentials属性</code>，这里给出jquery的ajax中该属性的配置:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">    xhrFields: &#123;</span><br><span class="line">        withCredentials: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>若配置了<code>Access-Control-Allow-Credentials:true</code>，而没有配置<code>withCredentials: true</code>，则请求中仍然不会包含cookie。</li>
<li>若配置了<code>withCredentials: true</code>，而没有配置<code>Access-Control-Allow-Credentials:true</code>，则请求会报错。</li>
</ul>
<h3 id="5-Access-Control-Allow-Methods"><a href="#5-Access-Control-Allow-Methods" class="headerlink" title="5).Access-Control-Allow-Methods"></a>5).<em>Access-Control-Allow-Methods</em></h3><p>用于预检请求的响应。其指明了实际请求所允许使用的HTTP方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: &lt;method&gt;[, &lt;method&gt;]*</span><br></pre></td></tr></table></figure></p>
<h3 id="6-Access-Control-Allow-Headers"><a href="#6-Access-Control-Allow-Headers" class="headerlink" title="6).Access-Control-Allow-Headers"></a>6).<em>Access-Control-Allow-Headers</em></h3><p>用于预检请求的响应。其指明了实际请求中允许<code>携带</code>的headers。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Headers: &lt;field-name&gt;[, &lt;field-name&gt;]*</span><br></pre></td></tr></table></figure></p>
<h1 id="三、JSONP方案"><a href="#三、JSONP方案" class="headerlink" title="三、JSONP方案"></a>三、JSONP方案</h1><p>和CORS方案不同，JSONP限制较多，例如JSONP方案仅仅支持GET请求，也很难对headers进行控制。JSONP方案主要是用于较老版本的浏览器，这些浏览器并不兼容CORS方案。</p>
<h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><p>JSONP原理很简单，<code>&lt;img&gt;</code>和<code>&lt;script&gt;</code>标签发起的跨域请求不会受到浏览器安全机制的检查，因此可以通过<code>&lt;script&gt;</code>标签发起跨域请求，获得一个<code>Javacript脚本</code>的响应。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&lt;domain&gt;/&lt;source&gt;"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">...</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="undefined">....</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>需要注意，这里获得到的资源是<code>Javascript脚本</code>，并不是<code>json</code>或<code>xml</code>等资源，为了获得具体的数据资源，返回的<code>Javascript脚本</code>需要具备特定的格式:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回Javascript脚本资源的格式</span></span><br><span class="line">callback(<span class="xml"><span class="tag">&lt;<span class="name">source</span>&gt;</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>返回的<code>Javascript脚本</code>是一个函数，并且会自动调用脚本中的<code>function callback(result)</code>的脚本函数，在函数中将会取得具体的数据资源。</p>
<h2 id="2-动态回调函数"><a href="#2-动态回调函数" class="headerlink" title="2.动态回调函数"></a>2.动态回调函数</h2><p>JSONP的响应的回调函数名是由服务器决定的，为了将回调函数的选择权交给WEB端，需要在JSONP请求中加入<code>callback</code>参数(参数名可以变更)，该参数告知服务器JSONP响应在WEB端的回调函数。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"&lt;domain&gt;/get-jsonp-cors?callback=jsonp_callback_name"</span>&gt;</span><span class="undefined"></span></span><br></pre></td></tr></table></figure></p>
<p>在服务器中，需要将该callback参数的指出来，用于包装资源:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route("/get-jsonp-cors")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_jsonp_cors</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 提取WEB端回调函数的名称</span></span><br><span class="line">    jsoncallback = request.args.get(<span class="string">"callback"</span>, <span class="string">"jsonp_callback"</span>)</span><br><span class="line">    <span class="comment"># 用js脚本包装资源</span></span><br><span class="line">    resp = <span class="string">"%s(%s)"</span> % (jsoncallback, source)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure></p>
<h2 id="3-动态JSONP请求"><a href="#3-动态JSONP请求" class="headerlink" title="3.动态JSONP请求"></a>3.动态JSONP请求</h2><p>上述直接写死<code>&lt;script&gt;</code>的方式并不方便动态扩展，可以采用对DOM树修改的方式，动态的引入<code>&lt;script&gt;</code>以发出请求。</p>
<h2 id="4-jQuery的JSONP"><a href="#4-jQuery的JSONP" class="headerlink" title="4.jQuery的JSONP"></a>4.jQuery的JSONP</h2><p>jQuery将上述提到的<code>动态回调函数</code>和<code>动态JSONP请求</code>问题都进行了较好的封装，可以直接使用:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'&lt;domain&gt;/&lt;source&gt;'</span>,</span><br><span class="line">    dataType: <span class="string">"jsonp"</span>,</span><br><span class="line">    <span class="comment">// 请求中告知服务器用于接收jsonp回调的函数的参数名</span></span><br><span class="line">    jsonp: <span class="string">"callback"</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">        <span class="comment">// result中是跨域的响应</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>下图是一个JSONP请求，JSONP回调函数(callback参数的值)是一个jquery生成的随机函数名, <code>_</code>参数相当于是请求的标识，该标识初始为jQuery载入时间戳(us)，以后每次请求递增1。<br><img src="jsonp.png" alt="jsonp"></p>
<h1 id="四、实际场景"><a href="#四、实际场景" class="headerlink" title="四、实际场景"></a>四、实际场景</h1><p>这里简单的设计了Flask的装饰器和Nginx的配置，在对后台业务代码无侵入的条件下，完成服务器对跨域请求的支持。由于<code>JSONP</code>只是为老版本的浏览器提供跨域解决方案，并只支持GET请求，不够灵活，因此不给出JSONP的后台支持方案。</p>
<h2 id="1-Flask跨域方案"><a href="#1-Flask跨域方案" class="headerlink" title="1.Flask跨域方案"></a>1.Flask跨域方案</h2><p>通过装饰器，可以对Flask后台代码进行很方便的跨域功能扩充，这里仅仅给出一个示例，主要是为了说明为了支持跨域，服务器端该如何设置。除了采用装饰器的方式，也可以采用<code>hook function</code>的方案，该方案主要是需要在后台初始化时配置好跨域行为。</p>
<h3 id="1-业务代码"><a href="#1-业务代码" class="headerlink" title="1).业务代码"></a>1).<em>业务代码</em></h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">app.py</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request, make_response</span><br><span class="line"><span class="keyword">import</span> cors</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对简单请求的支持</span></span><br><span class="line"><span class="meta">@app.route("/get-cors")</span></span><br><span class="line"><span class="meta">@cors.wrapper(allow_origin = "null")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cors</span><span class="params">()</span>:</span></span><br><span class="line">    resp = jsonify(&#123;</span><br><span class="line">        <span class="string">"result"</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="string">"message"</span> : <span class="string">"hello get cors"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对非简单请求(带预检请求的支持)</span></span><br><span class="line"><span class="meta">@app.route("/post-cors", methods=["post", "OPTIONS"])</span></span><br><span class="line"><span class="meta">@cors.wrapper(allow_origin = "null", allow_headers = "content-type")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_cors</span><span class="params">()</span>:</span></span><br><span class="line">    resp = jsonify(&#123;</span><br><span class="line">        <span class="string">"result"</span> : <span class="number">0</span>,</span><br><span class="line">        <span class="string">"message"</span> : <span class="string">"hello post cors"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-装饰器"><a href="#2-装饰器" class="headerlink" title="2).装饰器"></a>2).<em>装饰器</em></h3><p>下面只给出一个示例，仅限于对特定的CORS响应字段的支持。这个装饰器对简单和非简单请求均适用。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">cors.py</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request, make_response</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line">__cors_headers_allow_origin__ = <span class="string">"Access-Control-Allow-Origin"</span></span><br><span class="line">__cors_headers_allow_headers__ = <span class="string">"Access-Control-Allow-Headers"</span></span><br><span class="line">__cors_headers_allow_methods__ = <span class="string">"Access-Control-Allow-Methods"</span></span><br><span class="line">__cors_headers_expose_headers__ = <span class="string">"Access-Control-Expose-Headers"</span></span><br><span class="line">__cors_headers_max_age__ = <span class="string">"Access-Control-Max-Age"</span></span><br><span class="line">__cors_headers_allow_cred__ = <span class="string">"Access-Control-Allow-Credentials"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set_resp_header__</span><span class="params">(response, header, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        response.headers[header] = value</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allower</span><span class="params">(*,</span></span></span><br><span class="line"><span class="function"><span class="params">        allow_origin = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        allow_headers = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        allow_methods = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        expose_headers = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        options_max_age = None,</span></span></span><br><span class="line"><span class="function"><span class="params">        allow_cred = None)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deractor</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">        @functools.wraps(f)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*ks, **kws)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> request.method == <span class="string">"OPTIONS"</span>:</span><br><span class="line">                resp = make_response()</span><br><span class="line">                __set_resp_header__(resp, __cors_headers_allow_origin__, allow_origin)</span><br><span class="line">                __set_resp_header__(resp, __cors_headers_allow_headers__, allow_headers)</span><br><span class="line">                __set_resp_header__(resp, __cors_headers_allow_methods__, allow_methods)</span><br><span class="line">                __set_resp_header__(resp, __cors_headers_expose_headers__, expose_headers)</span><br><span class="line">                __set_resp_header__(resp, __cors_headers_max_age__, options_max_age)</span><br><span class="line">                __set_resp_header__(resp, __cors_headers_allow_cred__, allow_cred)</span><br><span class="line">                <span class="keyword">return</span> resp</span><br><span class="line">            resp = f(*ks, **kws)</span><br><span class="line">            <span class="keyword">if</span> isinstance(resp, str):</span><br><span class="line">                resp = make_response(rv)</span><br><span class="line">            __set_resp_header__(resp, __cors_headers_allow_origin__, allow_origin)</span><br><span class="line">            __set_resp_header__(resp, __cors_headers_allow_cred__, allow_cred)</span><br><span class="line">            <span class="keyword">return</span> resp</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> deractor</span><br></pre></td></tr></table></figure></p>
<p>若采用Flask作为Web后台框架，更加简便的是可以使用<a href="https://pypi.org/project/Flask-Cors/" target="_blank" rel="noopener">Flask-Cors</a>插件。</p>
<h2 id="2-Nginx跨域方案"><a href="#2-Nginx跨域方案" class="headerlink" title="2.Nginx跨域方案"></a>2.Nginx跨域方案</h2><p>Nginx对跨域问题一般采用CORS提供支持。所有的请求都会首先到Nginx，Nginx对请求进行判断，并在响应中添加合适的cors-headers，整体流程如下图所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   BROWSER                       NGINX                 SERVER</span><br><span class="line">|-----------|             |-----------------|       |-----------|</span><br><span class="line">|           |             |                 |       |           |</span><br><span class="line">|           |-----GET-----|---&gt;PROXY PASS---|------&gt;|           |</span><br><span class="line">|           |             |                 |       |           |</span><br><span class="line">|           |&lt;------------|&lt;--ADD HEADERS&lt;--|-------|           |</span><br><span class="line">|           |             |                 |       |           |</span><br><span class="line">|           |             |                 |       |           |</span><br><span class="line">|           |---OPTIONS---|-------|         |       |           |</span><br><span class="line">|           |             |       |         |       |           |</span><br><span class="line">|           |             |      \|/        |       |           |</span><br><span class="line">|           |&lt;------------|&lt;--ADD HEADER    |       |           |</span><br><span class="line">|           |             |                 |       |           |</span><br><span class="line">|           |----POST-----|---&gt;PROXY PASS---|------&gt;|           |</span><br><span class="line">|           |             |                 |       |           |</span><br><span class="line">|           |&lt;------------|&lt;--ADD HEADERS&lt;--|-------|           |</span><br><span class="line">|___________|             |_________________|       |___________|</span><br></pre></td></tr></table></figure></p>
<p>可简述为如下:</p>
<ul>
<li>GET请求通过NGINX直接路由给后端服务器，后端服务器的响应通过NGINX返回给浏览器前，将会在响应中添加CORS响应头。</li>
<li>发出的OPTIONS请求被NGINX直接消化，添加CORS响应头返回给浏览器, 实际的请求将会(如图中最下面的POST请求)同样会路由给后端服务器处理，再通过NGINX添加CORS响应头返回给浏览器。</li>
</ul>
<p>通用配置如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    location /ngx-get-cors &#123;</span><br><span class="line">        proxy_pass              ...</span><br><span class="line">        add_header              &lt;http-cors-header&gt; &lt;value&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /ngx-post-cors &#123;</span><br><span class="line">        if ($request_method = &apos;OPTIONS&apos;) &#123;</span><br><span class="line">            add_header              &lt;http-cors-header&gt; &lt;value&gt;;</span><br><span class="line">            return                  200;</span><br><span class="line">        &#125;</span><br><span class="line">        add_header              &lt;http-cors-header&gt; &lt;value&gt;;</span><br><span class="line">        proxy_pass http://localhost:4001;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>ngx_http_map_module</code>，也可以提供一些简单的请求判断，例如提供允许某些Origin(这里是允许<code>http://www.qq.com</code>和<code>http://www.baidu.com</code>访问)进行访问:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 白名单</span><br><span class="line">map $http_origin $allow_origin &#123;</span><br><span class="line">    default                                   &quot;&quot;;</span><br><span class="line">    ~[http|https]://www.qq.com                $http_origin;</span><br><span class="line">    ~[http|https]://www.baidu.com             $http_origin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 路由</span><br><span class="line">...</span><br><span class="line">location /ngx-post-cors &#123;</span><br><span class="line">    if ($request_method = &apos;OPTIONS&apos;) &#123;</span><br><span class="line">        add_header              &lt;http-cors-header&gt; &lt;value&gt;;</span><br><span class="line">        add_header              Access-Control-Allow-Origin &quot;$allow_origin&quot;;</span><br><span class="line">        return                  200;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_header              &lt;http-cors-header&gt; &lt;value&gt;;</span><br><span class="line">    add_header              Access-Control-Allow-Origin &quot;$allow_origin&quot;;</span><br><span class="line">    proxy_pass http://localhost:4001;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>前述的Python装饰器方案虽然对代码入侵相当少，但还是需要对代码进行修改和重启。通过Nginx反向代理就可以做到对业务代码零侵入，并且性能较好。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">MDN</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li>
<li><a href="https://www.cnblogs.com/chiangchou/p/jsonp.html" target="_blank" rel="noopener">jQuery JSONP跨域</a></li>
</ul>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>Arthur Lu</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://github.com/lsj9383/2018/11/14/跨域问题及解决方案/">http://github.com/lsj9383/2018/11/14/跨域问题及解决方案/</a></span>
                    </p>
                
                <!-- 
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                 -->
                <!-- 
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY<strong>?</span>
                     </p>
                 -->

            </section>
        
        <!-- <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section> -->
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2018/12/10/Git-Story/">Git Story</a>
            
            
            <a class="next" rel="next" href="/2018/08/16/UNIX指令/">UNIX指令</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Arthur Lu | Powered by <a href="https://hexo.io" target="_blank">Hexo</a></span>
    </div>
</footer>

    </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
